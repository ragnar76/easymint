' ----------------------------------------------------------------------------
'
'  EasyMiNT install 1.0 von M.A. Kehr
'
'  17.05.2013, 12:48:00
'
'  (faceVALUE V3.2 PL5· , vom 19.07.03)
'
' ----------------------------------------------------------------------------
'
$m128000                          ! Speicherverbrauch eintragen
compiled!=BYTE{BASEPAGE+256}<>96
' --CMP
IF NOT compiled!
  RESERVE 128000                  ! Speicherverbrauch eintragen
  CHDRIVE "F"                     !***Pfad einstellen (im Interpreter)
  CHDIR "\EASYMINT.1_8\"         !***Pfad einstellen (im Interpreter)
ENDIF
' --CMP
'
ON BREAK GOSUB system_restore !This line can be deleted before compiling   !-CMP
ON ERROR GOSUB system_error   !This line can be deleted before compiling   !-CMP
@start_up                     !Code produced using faceVALUE
' ------------------------------------------------------------------------
'Wrinkle-Information / Dokumentation:
'
>PROCEDURE wrinkles_info
' ----------------------------------------------------------------------------
' Messagewindow-wrinkle    Ω1998 by Holger Herzog
'                                Vorgartenstr. 9
'                              D-66424 Homburg
'
' Callable routines:
'
' PROCEDURE messagewin_open(title$,maxlines%,x&,y&,w&,h&,icfyicon&)
'
' Opens a userwindow for displaying messagelines. The string in title$
' will be showed in the window title. maxlines% is used for dimming the
' scroll-back area. Set the windowsize in x&, y&, w& and h&. If all these
' variables are set to (-1), the window will be opened in full size.
' icfyicon& can contain the tree number of an iconify-icon for this window.
' Otherwise set it to (-1).
'
'
' PROCEDURE messagewin_print(line$)
'
' Outputs the line line$ in the messagewindow.
'
'
' PROCEDURE messagewin_close
'
' Closes the messagewindow (if opened).
'
' ---------------------------------------------------------------------------
' Textlist-Wrinkle V1.0, Ω29.03.1997 Holger Herzog
'                                    Vorgartenstr. 9
'                                  D-66424 Homburg
'
' Callable routines:
'
' FUNCTION textlist_win_open(title$,info$,mode&,tool&,tree&,userhandle&,
'                            x&,y&,w&,h&,iconify&,num%,VAR liste$())
'
' Opens a userwindow for textlist-use. See win_open for information about
' title$, info$, tree&, userhandle&, x&, y&, w&, h& and iconify&. See
' win_kind_calc for information about mode& and tool&. Fill out the array
' liste$() with the textlines to display. num% is the number of lines that
' will be shown. If x&, y&, w& and h& are set to (-1), the window will appear
' in full screen-size. To suppress the infoline, set info$="". The function
' returns the window-handle of the text-window or '0' if error.
'
'
' PROCEDURE textlist_draw(index&,off_x%,off_y%,cx&,cy&,cw&,ch&,num%,
'                         VAR list$(),selected!())
'
' Draws a textlist in a userwindow. Normally called in user_window_content
' (see also). Most parameters are avaliable in user_window_content anyway:
'       index&,off_x%,off_y%,cx&,cy&,cw&,ch&
' The first num% lines of the array list$() will be drawn in the userwindow
' (according to the offsets and the clipping-rectangle). Lines with the
' selected!()-flag set will be drawn inverted.
'
'
' FUNCTION textlist_click(index&,mx&,my&,mb&,ks&,mc&,dd!,num%,
'                         selected!(),hash&())
'
' Handles mouseclicks into a textlist-userwindow. This function usually is
' called in user_mouse (see also). Like in textlist_draw, most parameters
' are availiable anyway:
'       index&,mx&,my&,mb&,ks&,mc&
' num% is the number of lines the textlist have (like in textlist_draw).
' Dito selected!(), it may have changed after calling
' this function (as this is its main-sentence).
' The return-value of textlist_click usually is -1. If the user makes a
' doubleclick onto a certain entry, textlist_click will return the value
' of the hash&()-array of this entry. If hash&() is negative, the entry will
' be not selectable.
' If dd! is set to TRUE, a long click with the left mousebutton will lead
' to a movebox and the user can drag and drop the entries. After that,
' user_textlist_dragdrop will be called where you can do your stuff.
'
'
' PROCEDURE list_redraw(index&,line&)
'
' Redraws one line (line&) in window index&. Use this if you have changed
' the content or the selected!-flag of a certain line for redraw.
'
'
' PROCEDURE textlist_resize_sliders(index&,num%,VAR liste$())
'
' Call this procedure if you have changed list-texts or fontsize to resize
' the window and the sliders. index& is the FV-index of the text-list-
' window.
'
'
RETURN
'
' ------------------------------------------------------------------------
'
> PROCEDURE user_inline_load
'
' Diese Routine wird einmalig aufgerufen, wenn das Programm gestartet wurde.
' Die folgenden Zeilen dienen dem Laden der INLINE-Daten, sofern dies nicht
' bereits geschehen ist.
'
' Es ist ebenso mîglich, die INLINE-Daten von Hand zu laden. (s. Handbuch
' des GFA-Basic-Editors zum Thema 'INLINE')
'
LOCAL file$,fh&,ret%,lof%                     ! -CMP
INLINE faceval_sys%,2901
'
' Die folgenden Zeilen kînnen vor dem öbersetzen gelîscht werden.
'
' CMP: ergo!pro-Flag um die Zeilen vor dem öbersetzen automatisch zu lîschen.
'      Stellen Sie sicher, dass die INLINE-Daten *VOR* dem öbersetzeb in
'      jedem Falle geladen sind!
'
' --CMP
IF BYTE{SUCC(faceval_sys%)}=0
LET file$="fv_sys.inl"+CHR$(0)
LET ret%=GEMDOS(61,L:V:file$,0)
IF ret%>0
LET fh&=ret%
ret%=GEMDOS(66,L:0,fh&,2)
LET lof%=ret%
LET ret%=GEMDOS(66,L:0,fh&,0)
IF ret%=0
LET ret%=GEMDOS(63,fh&,L:lof%,L:faceval_sys%)
IF ret%=lof%
LET ret%=GEMDOS(62,fh&)
ENDIF
ENDIF
ENDIF
IF ret%<>0
~FORM_ALERT(1,"[3][INLINE wurde nicht |geladen! |Fehler: ]"+STR$(ret%)+"[Abbruch]")
EDIT
ELSE
~GEMDOS(340,22,L:faceval_sys%,L:lof%) ! cache flush
ENDIF
ENDIF
' --CMP
'
RETURN
>PROCEDURE user_var_index
'
' ---------------------------------------------------------------------------
' Objektbaum-Namen:
' system&                             : Dialog
' fvt_asci&                           : Dialog
' fvt_alst&                           : Dialog
' fvt_work&                           : Dialog
' fvt_prog&                           : Dialog
' fvt_popu&                           : Dialog
' fvt_maus&                           : Dialog
' about&                              : Dialog
' mainmenu&                           : MenÅ
' pre&                                : Dialog
' pfade&                              : Dialog
' message&                            : Dialog
' message2&                           : Dialog
' startprg&                           : Dialog
' nic&                                : Dialog
' ppp&                                : Dialog
' preinst&                            : Dialog
' ---------------------------------------------------------------------------
' Objekt-Namen:
' lw_c&                               : Objekt im Baum fvt_popu&
' lw_d&                               : Objekt im Baum fvt_popu&
' lw_e&                               : Objekt im Baum fvt_popu&
' lw_f&                               : Objekt im Baum fvt_popu&
' lw_g&                               : Objekt im Baum fvt_popu&
' lw_h&                               : Objekt im Baum fvt_popu&
' lw_i&                               : Objekt im Baum fvt_popu&
' lw_j&                               : Objekt im Baum fvt_popu&
' lw_k&                               : Objekt im Baum fvt_popu&
' lw_l&                               : Objekt im Baum fvt_popu&
' lw_m&                               : Objekt im Baum fvt_popu&
' lw_n&                               : Objekt im Baum fvt_popu&
' lw_o&                               : Objekt im Baum fvt_popu&
' lw_p&                               : Objekt im Baum fvt_popu&
' lw_q&                               : Objekt im Baum fvt_popu&
' lw_r&                               : Objekt im Baum fvt_popu&
' lw_s&                               : Objekt im Baum fvt_popu&
' lw_t&                               : Objekt im Baum fvt_popu&
' lw_u&                               : Objekt im Baum fvt_popu&
' lw_v&                               : Objekt im Baum fvt_popu&
' lw_w&                               : Objekt im Baum fvt_popu&
' lw_x&                               : Objekt im Baum fvt_popu&
' lw_y&                               : Objekt im Baum fvt_popu&
' lw_z&                               : Objekt im Baum fvt_popu&
' lw_1&                               : Objekt im Baum fvt_popu&
' lw_2&                               : Objekt im Baum fvt_popu&
' lw_3&                               : Objekt im Baum fvt_popu&
' lw_4&                               : Objekt im Baum fvt_popu&
' lw_5&                               : Objekt im Baum fvt_popu&
' lw_6&                               : Objekt im Baum fvt_popu&
' ext_c&                              : Objekt im Baum fvt_popu&
' ext_d&                              : Objekt im Baum fvt_popu&
' ext_e&                              : Objekt im Baum fvt_popu&
' ext_f&                              : Objekt im Baum fvt_popu&
' ext_g&                              : Objekt im Baum fvt_popu&
' ext_h&                              : Objekt im Baum fvt_popu&
' ext_i&                              : Objekt im Baum fvt_popu&
' ext_j&                              : Objekt im Baum fvt_popu&
' ext_k&                              : Objekt im Baum fvt_popu&
' ext_l&                              : Objekt im Baum fvt_popu&
' ext_m&                              : Objekt im Baum fvt_popu&
' ext_n&                              : Objekt im Baum fvt_popu&
' ext_o&                              : Objekt im Baum fvt_popu&
' ext_p&                              : Objekt im Baum fvt_popu&
' ext_q&                              : Objekt im Baum fvt_popu&
' ext_r&                              : Objekt im Baum fvt_popu&
' ext_s&                              : Objekt im Baum fvt_popu&
' ext_t&                              : Objekt im Baum fvt_popu&
' ext_u&                              : Objekt im Baum fvt_popu&
' ext_v&                              : Objekt im Baum fvt_popu&
' ext_w&                              : Objekt im Baum fvt_popu&
' ext_x&                              : Objekt im Baum fvt_popu&
' ext_y&                              : Objekt im Baum fvt_popu&
' ext_z&                              : Objekt im Baum fvt_popu&
' ext_1&                              : Objekt im Baum fvt_popu&
' ext_2&                              : Objekt im Baum fvt_popu&
' ext_3&                              : Objekt im Baum fvt_popu&
' ext_4&                              : Objekt im Baum fvt_popu&
' ext_5&                              : Objekt im Baum fvt_popu&
' ext_6&                              : Objekt im Baum fvt_popu&
' smilemouse&                         : Objekt im Baum fvt_maus&
' version1&                           : Objekt im Baum about&
' version2&                           : Objekt im Baum about&
' version3&                           : Objekt im Baum about&
' version4&                           : Objekt im Baum about&
' version5&                           : Objekt im Baum about&
' aboutok&                            : Objekt im Baum about&
' mm_about&                           : Objekt im Baum mainmenu&
' mm_quit&                            : Objekt im Baum mainmenu&
' pre_info&                           : Objekt im Baum pre&
' pakete&                             : Objekt im Baum pre&
' net&                                : Objekt im Baum pre&
' devel&                              : Objekt im Baum pre&
' libs&                               : Objekt im Baum pre&
' x11&                                : Objekt im Baum pre&
' rpmsja&                             : Objekt im Baum pre&
' filecheck&                          : Objekt im Baum pre&
' shutdown&                           : Objekt im Baum pre&
' mico&                               : Objekt im Baum pre&
' preabbr&                            : Objekt im Baum pre&
' preok&                              : Objekt im Baum pre&
' pf_info&                            : Objekt im Baum pfade&
' login&                              : Objekt im Baum pfade&
' naes_drkt&                          : Objekt im Baum pfade&
' xaaesstrt&                          : Objekt im Baum pfade&
' plaintos&                           : Objekt im Baum pfade&
' naespfad&                           : Objekt im Baum pfade&
' naescar&                            : Objekt im Baum pfade&
' xaaespfad&                          : Objekt im Baum pfade&
' pathabbr&                           : Objekt im Baum pfade&
' pathok&                             : Objekt im Baum pfade&
' mes1&                               : Objekt im Baum message&
' mes2&                               : Objekt im Baum message&
' mes3&                               : Objekt im Baum message&
' mes4&                               : Objekt im Baum message&
' mes5&                               : Objekt im Baum message&
' mes6&                               : Objekt im Baum message&
' mes7&                               : Objekt im Baum message&
' infoabbr&                           : Objekt im Baum message&
' mes_ok&                             : Objekt im Baum message&
' mes1_00&                            : Objekt im Baum message2&
' mes2_00&                            : Objekt im Baum message2&
' mes3_00&                            : Objekt im Baum message2&
' mes4_00&                            : Objekt im Baum message2&
' mes5_00&                            : Objekt im Baum message2&
' mes6_00&                            : Objekt im Baum message2&
' mes7_00&                            : Objekt im Baum message2&
' inf2abbr&                           : Objekt im Baum message2&
' mes_ok_00&                          : Objekt im Baum message2&
' appname&                            : Objekt im Baum startprg&
' nic_info&                           : Objekt im Baum nic&
' kuerzel&                            : Objekt im Baum nic&
' ipadr&                              : Objekt im Baum nic&
' netmask&                            : Objekt im Baum nic&
' defaultr&                           : Objekt im Baum nic&
' gateway&                            : Objekt im Baum nic&
' dns&                                : Objekt im Baum nic&
' domain&                             : Objekt im Baum nic&
' domaine&                            : Objekt im Baum nic&
' hn&                                 : Objekt im Baum nic&
' nw_abbr&                            : Objekt im Baum nic&
' nw_ok&                              : Objekt im Baum nic&
' ispname&                            : Objekt im Baum ppp&
' ppp_info&                           : Objekt im Baum ppp&
' atz&                                : Objekt im Baum ppp&
' timeout&                            : Objekt im Baum ppp&
' device&                             : Objekt im Baum ppp&
' speed&                              : Objekt im Baum ppp&
' ispnumber&                          : Objekt im Baum ppp&
' user&                               : Objekt im Baum ppp&
' passwd&                             : Objekt im Baum ppp&
' nameserver&                         : Objekt im Baum ppp&
' pppdomain&                          : Objekt im Baum ppp&
' localip&                            : Objekt im Baum ppp&
' remoteip&                           : Objekt im Baum ppp&
' ppp_abbr&                           : Objekt im Baum ppp&
' ppp_ok&                             : Objekt im Baum ppp&
' preinfo&                            : Objekt im Baum preinst&
' compi&                              : Objekt im Baum preinst&
' boot&                               : Objekt im Baum preinst&
' ext2&                               : Objekt im Baum preinst&
' pabbr&                              : Objekt im Baum preinst&
' pok&                                : Objekt im Baum preinst&
 '
' ---------------------------------------------------------------------------
' Status-Variablen: (Details in der Prozedur user_rsc_var_init)
 '
' lw_c_var!                           : anwÑhlbar im Baum fvt_popu&
' lw_d_var!                           : anwÑhlbar im Baum fvt_popu&
' lw_e_var!                           : anwÑhlbar im Baum fvt_popu&
' ext_c_var!                          : anwÑhlbar im Baum fvt_popu&
' ext_d_var!                          : anwÑhlbar im Baum fvt_popu&
' ext_e_var!                          : anwÑhlbar im Baum fvt_popu&
' pakete_var!                         : anwÑhlbar im Baum pre&
' net_var!                            : anwÑhlbar im Baum pre&
' devel_var!                          : anwÑhlbar im Baum pre&
' libs_var!                           : anwÑhlbar im Baum pre&
' x11_var!                            : anwÑhlbar im Baum pre&
' rpmsja_var!                         : anwÑhlbar im Baum pre&
' filecheck_var!                      : anwÑhlbar im Baum pre&
' shutdown_var!                       : anwÑhlbar im Baum pre&
' mico_var!                           : anwÑhlbar im Baum pre&
' login_var&                          : Radiobutton-Set im Baum pfade&
' naespfad_var$                       : editierbarer Text im Baum pfade&
' naescar_var!                        : anwÑhlbar im Baum pfade&
' xaaespfad_var$                      : editierbarer Text im Baum pfade&
' kuerzel_var$                        : editierbarer Text im Baum nic&
' ipadr_var$                          : editierbarer Text im Baum nic&
' netmask_var$                        : editierbarer Text im Baum nic&
' gateway_var$                        : editierbarer Text im Baum nic&
' dns_var$                            : editierbarer Text im Baum nic&
' domaine_var$                        : editierbarer Text im Baum nic&
' hn_var$                             : editierbarer Text im Baum nic&
' ispname_var$                        : editierbarer Text im Baum ppp&
' atz_var$                            : editierbarer Text im Baum ppp&
' timeout_var$                        : editierbarer Text im Baum ppp&
' device_var&                         : Radio-Popup im Baum ppp&
' speed_var&                          : Radio-Popup im Baum ppp&
' ispnumber_var$                      : editierbarer Text im Baum ppp&
' user_var$                           : editierbarer Text im Baum ppp&
' passwd_var$                         : editierbarer Text im Baum ppp&
' nameserver_var$                     : editierbarer Text im Baum ppp&
' pppdomain_var$                      : editierbarer Text im Baum ppp&
' localip_var$                        : editierbarer Text im Baum ppp&
' remoteip_var$                       : editierbarer Text im Baum ppp&
' compi_var&                          : Radio-Popup im Baum preinst&
' boot_var&                           : Radio-Popup im Baum preinst&
' ext2_var&                           : Radio-Popup im Baum preinst&
 '
' ---------------------------------------------------------------------------
' Fenster-Typen:
 '
 '
' ---------------------------------------------------------------------------
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
' messagewin_userhandle_&       : userhandle of the messagewin-window   !ÍÍFVW:messagewinÍÍ
' messagewin_windowhandle_&     : internal (messagewin-wrinkle)         !ÍÍFVW:messagewinÍÍ
' messagewin_$()                : internal (messagewin-wrinkle)         !ÍÍFVW:messagewinÍÍ
' messagewin_selected_!()       : internal (messagewin-wrinkle)         !ÍÍFVW:messagewinÍÍ
' messagewin_maxline_%          : internal (messagewin-wrinkle)         !ÍÍFVW:messagewinÍÍ
' messagewin_entries_%          : internal (messagewin-wrinkle)         !ÍÍFVW:messagewinÍÍ
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
 '
RETURN
> FUNCTION user_systemcheck
$F%
'
' Diese Funktion wird unverzÅglich nach dem Programmstart aufgerufen,
' sofern die Anforderungen der Systemprozedur 'SYSTEMCHECK' erfÅllt
' sind. Beachten Sie: Die RSC-DATEI ist NOCH NICHT GELADEN! Wenn es
' spezielle Anforderungen fÅr das Programm gibt, dann kînnen diese
' Anforderungen an dieser Stelle ÅberprÅft werden.
'
' Um das Programm fortzusetzen, ist TRUE zurÅckzugeben.
' Um das Programm abzubrechen, ist FALSE zurÅckzugeben.
'
' Wenn das Programm abgebrochen wird, sollte dem Benutzer angezeigt
' werden, WESHALB das Programm abgebrochen wurde.
'
' Wenn es nichts spezielles zu ÅberprÅfen gibt, kann diese Funktion, mit
' Ausnahme der Zeile 'RETURN TRUE', leer gelassen werden.
'
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN TRUE
ENDFUNC
>PROCEDURE user_rsc_var_init
'
'  Hier mÅssen alle Status-Variablen korrekt vorbelegt werden.
'  Ebenso mÅssen die Arrays fÅr die Listboxen hier dimensioniert
'  und initialisiert werden.
'
'  Diese Prozedur wird einmal beim Programmstart durchlaufen.
'  Danach werden die entsprechenden Dialogobjekte nach
'  den hier getÑtigten Einstellungen eingerichtet.
'
'  Werden die Befehle DIM, LET und CLR benutzt, um die Werte zu
'  setzen, so erkennt faceVALUE dies beim Update. Nicht erkannte
'  Werte werden beim Update wieder eingefÅgt.
'
'    LET xxx_var&=5        => wird erkannt
'    xxx_var&=5            => wird nicht erkannt
'
'  Sollen einige Werte hier explizit NICHT gesetzt werden, so
'  kann die entsprechende Zeile mit REM auskommentiert werden:
'
'    REM LET xxx_var&=5    => wird erkannt
'    ' LET xxx_var&=5      => wird nicht erkannt
'
current_menubar&=mainmenu&      !in diese Variable den MenÅbaum-Index eintragen
' current_menubar&=-1
'
' snap_windows!=TRUE
quit_alert!=TRUE
'
LET lw_c_var!=FALSE                       ! TRUE/FALSE - Baum: fvt_popu&
LET lw_d_var!=FALSE                       ! TRUE/FALSE - Baum: fvt_popu&
LET lw_e_var!=FALSE                       ! TRUE/FALSE - Baum: fvt_popu&
LET ext_c_var!=FALSE                      ! TRUE/FALSE - Baum: fvt_popu&
LET ext_d_var!=FALSE                      ! TRUE/FALSE - Baum: fvt_popu&
LET ext_e_var!=FALSE                      ! TRUE/FALSE - Baum: fvt_popu&
LET pakete_var!=FALSE                     ! TRUE/FALSE - Baum: pre&
LET net_var!=FALSE                        ! TRUE/FALSE - Baum: pre&
LET devel_var!=FALSE                      ! TRUE/FALSE - Baum: pre&
LET libs_var!=FALSE                       ! TRUE/FALSE - Baum: pre&
LET x11_var!=FALSE                        ! TRUE/FALSE - Baum: pre&
LET rpmsja_var!=FALSE                     ! TRUE/FALSE - Baum: pre&
LET filecheck_var!=FALSE                  ! TRUE/FALSE - Baum: pre&
LET shutdown_var!=FALSE                   ! TRUE/FALSE - Baum: pre&
LET mico_var!=FALSE                       ! TRUE/FALSE - Baum: pre&
LET login_var&=1                          ! min=1/max=4 - Baum: pfade&
LET naespfad_var$=""                      ! max LÑnge: 65 - Baum: pfade&
LET naescar_var!=FALSE                    ! TRUE/FALSE - Baum: pfade&
LET xaaespfad_var$=""                     ! max LÑnge: 65 - Baum: pfade&
LET kuerzel_var$=""                       ! max LÑnge: 4 - Baum: nic&
LET ipadr_var$=""                         ! max LÑnge: 12 - Baum: nic&
LET netmask_var$=""                       ! max LÑnge: 12 - Baum: nic&
LET gateway_var$=""                       ! max LÑnge: 12 - Baum: nic&
LET dns_var$=""                           ! max LÑnge: 12 - Baum: nic&
LET domaine_var$=""                       ! max LÑnge: 20 - Baum: nic&
LET hn_var$=""                            ! max LÑnge: 20 - Baum: nic&
LET ispname_var$=""                       ! max LÑnge: 20 - Baum: ppp&
LET atz_var$=""                           ! max LÑnge: 4 - Baum: ppp&
LET timeout_var$=""                       ! max LÑnge: 3 - Baum: ppp&
LET device_var&=1                         ! min=1/max=5 - Baum: ppp&
LET speed_var&=1                          ! min=1/max=7 - Baum: ppp&
LET ispnumber_var$=""                     ! max LÑnge: 30 - Baum: ppp&
LET user_var$=""                          ! max LÑnge: 50 - Baum: ppp&
LET passwd_var$=""                        ! max LÑnge: 30 - Baum: ppp&
LET nameserver_var$=""                    ! max LÑnge: 12 - Baum: ppp&
LET pppdomain_var$=""                     ! max LÑnge: 30 - Baum: ppp&
LET localip_var$=""                       ! max LÑnge: 12 - Baum: ppp&
LET remoteip_var$=""                      ! max LÑnge: 12 - Baum: ppp&
LET compi_var&=1                          ! min=1/max=12 - Baum: preinst&
LET boot_var&=1                           ! min=1/max=30 - Baum: preinst&
LET ext2_var&=1                           ! min=1/max=30 - Baum: preinst&
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN
> PROCEDURE user_on_open
'
' Diese Prozedur wird aufgerufen, nachdem die RSC-Datei geladen wurde,
' unmittelbar, bevor die Hauptschleife betreten wird. Hier kînnen
' Fenster, Toolboxen usw. geîffnet werden, oder auch Initialisierungen
' wie etwa das Laden einer INF-Datei usw. vorgenommen werden.
'
' Wenn das Programm als Accessory lÑuft, wird diese Prozedur JEDESMAL
' aufgerufen, wenn das ACCESSORY GEôFFNET WIRD. Wenn bestimmte Dinge nur
' einmal ausgefÅhrt werden sollen, so kann bspw. ein globales Flag dazu
' benutzt werden, die MehrfachausfÅhrung dieser Teile zu verhindern.
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
@messagewin_open(" Messagewindow ",50,200,20,400,180,iconify_icon_1&)   !ÍÍFVW:messagewinÍÍ
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN
>PROCEDURE user_rsc_interact(index&,tree&,object&,mc&,sub_me&)
  '
  '  <index&> Index des Fensters in window_array&(index&,x)
  '           Wenn das Objekt aus der MenÅzeile ist: <index&>=-1
  '   <tree&> Index des Objektbaumes
  ' <object&> Index des selektierten Objektes (Åber Mausklick oder Shortcut)
  '     <mc&> Anzahl der Mausklicks (1=normal oder Shortcut / 2=Doppelklick)
  ' <sub_me&> ausgewÑhlter MenÅeintrag in Popup-MenÅs
  '
  SELECT tree&
    '
    ' ------------------------------------------------------------------------
    '
  CASE about&
    SELECT object&
    CASE aboutok&
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE mainmenu&
    SELECT object&
    CASE mm_about&
    CASE mm_quit&
      exit_program!=TRUE
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE pre&
    SELECT object&
    CASE pre_info&
    CASE pakete&
    CASE net&
    CASE devel&
    CASE libs&
    CASE x11&
    CASE preabbr&
    CASE preok&
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE pfade&
    SELECT object&
    CASE pf_info&
    CASE login&
    CASE naes_drkt&
    CASE xaaesstrt&
    CASE plaintos&
    CASE naespfad&
    CASE xaaespfad&
    CASE pathabbr&
    CASE pathok&
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE message&
    SELECT object&
    CASE infoabbr&
    CASE mes_ok&
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE message2&
    SELECT object&
    CASE inf2abbr&
    CASE mes_ok_00&
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE nic&
    SELECT object&
    CASE nic_info&
    CASE kuerzel&
    CASE ipadr&
    CASE netmask&
    CASE gateway&
    CASE dns&
    CASE domaine&
    CASE hn&
    CASE nw_abbr&
    CASE nw_ok&
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE ppp&
    SELECT object&
    CASE ispname&
    CASE ppp_info&
    CASE atz&
    CASE timeout&
    CASE device&
    CASE speed&
    CASE ispnumber&
    CASE user&
    CASE passwd&
      ' Der Text in passwd_var$ wurde geÑndert...
    CASE nameserver&
    CASE pppdomain&
    CASE localip&
    CASE remoteip&
    CASE ppp_abbr&
    CASE ppp_ok&
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
  CASE preinst&
    SELECT object&
    CASE preinfo&
    CASE compi&
    CASE boot&
    CASE ext2&
    CASE pabbr&
    CASE pok&
    ENDSELECT
    '
    ' ------------------------------------------------------------------------
    '
    '
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
    '
  ENDSELECT
RETURN
>PROCEDURE user_rsc_context_help(tree&)
  '
  ' Von hier aus wird der ST-Guide aufgerufen. Bitte die Namen
  ' der entsprechenden Hilfeseiten eintragen:
  '
  SELECT tree&
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
  DEFAULT
    @call_st_guide("EASYMINT.hyp","")
  ENDSELECT
RETURN
> PROCEDURE user_rsc_draw_extra(userhandle&,index&,tree&,tree%,cx&,cy&,cw&,ch&)
LOCAL x&,y&,w&,h&
' ~GRAF_MOUSE(256,0) !hidem - Beim Zeichnen Mauszeiger abschalten!
'
' Diese Prozedur kann verwendet werden, um Dinge in Dialoge zu zeichnen, die
' nicht in die RSC-Datei eingebracht werden kînnen. Das Clipping-Rechteck
' ist beim Aufruf dieser Routine bereits eingestellt (beim Durchlaufen
' der Rechteckliste) und sollte NICHT GEéNDERT WERDEN! Andernfalls kînnen
' andere Objekte oder auch Fenster Åberzeichnet werden.
'
' Alle Koordinaten sind relativ zur linken oberen Ecke der ArbeitsflÑche
' des Fensters. Ausgenommen sind die Blit-Befehle, da diese stelts relativ
' zum Ursprung des gesamten Bildschirms arbeiten.
'
' <userhandle&> enthÑlt die Benutzerkennung des Fensters, die beim ôffnen
'               eingestellt wurde, oder -1 bei Dialogfenstern
' <index&>      enthÑlt den Fensterindex im Feld window_array&(index&,x)
' <tree&>       enthÑlt den Baumindex des Dialoges, Toolstrips oder Toolbars
' <tree%>       enthÑlt die Adresse des Dialogbaumes
' <cx&>,<cy&>,<cw&>,<ch&> enthÑlt die Koordinaten des Clippingrechtecks
'
' Die Zeichen- und Blitkommandos sollten in Grîûe und Position auf ein Rechteck
' angepasst werden, das etwa durch ein IBOX/BOX-Objekt im Dialog vertreten wird.
' BOX sorgt dann bereits fÅr den Hintergrund, IBOX nicht. Die Position und Grîûe
' eines solchen Objektes kann mittels der folgenden Prozedur ermittelt werden:
'
' @rsc_ob_xywh(tree%,object&,x&,y&,w&,h&)
'
' <tree%> verlangt die Adresse des Dialogbaumes
' <object&> verlangt den Objektindex des Objektes
' <x&> nimmt den Wert der X-Koordinate an
' <y&> nimmt den Wert der Y-Koordinate an
' <w&> nimmt den Wert der Objektbreite an
' <h&> nimmt den Wert der Objekthîhe an
'
' Es empfiehlt sich eine SELECT/CASE-Struktur anzulegen,
' die dem folgenden Beispiel entsprechen kînnte:
'
'   SELECT tree&
'   CASE dialog_1&
'     @rsc_ob_xywh(tree%,help2&,x&,y&,w&,h&)
'     DEFFILL 1,2,5
'     PBOX x&,y&,PRED(ADD(x&,w&)),PRED(ADD(y&,h&))
'   CASE toolstrip_h&
'     @rsc_ob_xywh(tree%,t_clip&,x&,y&,w&,h&)
'     DEFFILL 1,2,5
'     PBOX x&,y&,PRED(ADD(x&,w&)),PRED(ADD(y&,h&))
'   ENDSELECT
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
' ~GRAF_MOUSE(257,0) !showm - Mauszeiger wieder einschalten
RETURN
> PROCEDURE user_window_content(index&,userhandle&,off_x%,off_y%,cx&,cy&,cw&,ch&)
' ~GRAF_MOUSE(256,0) !hidem - Beim Zeichnen Mauszeiger abschalten!
'
' Dieses Unterprogramm wird aufgerufen, wenn ein Userfenster neu
' gezeichnet werden muss (sog. 'Redraw'). Hier sollte der KOMPLETTE
' Fensterinhalt gezeichnet werden. Die x- und y-Offsets werden automatisch
' von der Engine gesetzt und sind IMMER gÅltig. Das Clipping-Rechteck
' sollte NICHT geÑndert werden. Es ist bereits VOR dem Aufruf dieser
' Routine gesetzt wurde (beim Durchlaufen der Rechteckliste).
'
' Alle Koordinaten sind relativ zur linken oberen Ecke der ArbeitsflÑche
' des Fensters. Ausgenommen sind die Blit-Befehle, da diese stelts relativ
' zum Ursprung des gesamten Bildschirms arbeiten. Von ALLEN Koordinaten von
' Fensterinhalten, die sich mit den Scrollbalken scrollen lassen sollen,
' sind vor dem Zeichnen die Werte <off_x%> bzw. <off_y%> zu subtrahieren.
'
' <index&>      enthÑlt den Index des Fensters in window_array&(index&,x)
' <userhandle&> enthÑlt die Benutzerkennung des Fensters
' <off_x%>      aktueller x-Versatz des Fensterinhalts durch das Scrolling
' <off_y%>      aktueller y-Versatz des Fensterinhalts durch das Scrolling
' <cx&>,<cy&>,<cw&>,<ch&> aktuelles Clipping-Rechteck
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
IF userhandle&=messagewin_userhandle_&                                  !ÍÍFVW:messagewinÍÍ
  @textlist_draw(index&,off_x%,off_y%,cx&,cy&,cw&,ch&,messagewin_entries_%,messagewin_$(),messagewin_selected_!())      !ÍÍFVW:messagewinÍÍ
ENDIF                                                                   !ÍÍFVW:messagewinÍÍ
' ---------------------------------------------------------------------------   !ÍÍFVW:textlistÍÍ
' Textlist-Wrinkle:     (Ω1997 by Holger Herzog)                                !ÍÍFVW:textlistÍÍ
'                                                                               !ÍÍFVW:textlistÍÍ
' Draw your textlists here. Just call textlist_draw like it is described in     !ÍÍFVW:textlistÍÍ
' wrinkle_info.                                                                 !ÍÍFVW:textlistÍÍ
'                                                                               !ÍÍFVW:textlistÍÍ
' SELECT userhandle&                                                            !ÍÍFVW:textlistÍÍ
' CASE xxx                                                                      !ÍÍFVW:textlistÍÍ
'   @textlist_draw(index&,off_x%,off_y%,cx&,cy&,cw&,ch&,num%,list$(),selected!())       !ÍÍFVW:textlistÍÍ
' ENDSELECT                                                                     !ÍÍFVW:textlistÍÍ
'                                                                               !ÍÍFVW:textlistÍÍ
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
' ~GRAF_MOUSE(257,0) !showm - Mauszeiger wieder einschalten
RETURN
> PROCEDURE user_mouse(handle&,userhandle&,index&,mx&,my&,mc&,mb&,ks&)
'
' Diese Prozedur wird aufgerufen, wenn der Benutzer mit der Maus in ein
' Userfester klickt. Es ist nicht nîtig, zu ÅberprÅfen, ob der Mauszeiger
' tatsÑchlich auf die ArbeitsflÑche des Fensters zeigt, da diese Routine
' andernfalls nicht angesprungen wird.
'
' Um die ArbeitsflÑche des Fensters zu ermitteln, kann folgender Aufruf
' benutzt werden:
'
' LOCAL x&,y&,w&,h&
' @win_get_workarea(index&,x&,y&,w&,h&)
'
' <x&>,<y&>,<w&> und <h&> enthalten dann die Koordinaten, Breite und Hîhe
' der ArbeitsflÑche des Fensters.
'
' <handle&>     enthÑlt die AES-Kennung des Fensters
' <userhandle&> enthÑlt die Benutzerkennung des Fensters
' <index&>      enthÑlt den Fensterindex im window_array&(index&,x)
' <mx&>         die x-Mausposition, an der der Klick erfolgte
' <my&>         die y-Mausposition, an der der Klick erfolgte
' <mc&>         enthÑlt die Anzahl der Mausklicks (1=normal/2=Doppelklick)
' <mb&>         enthÑlt den Mausknopf (1=links/2=rechts)
' <ks&>         der Status der Tastaturumschalttasten beim Klick
'     IF AND(ks&,&X11): Shift-Taste gedrÅckt (eine oder beide)
'     IF BTST(ks&,2)  : Control-Taste gedrÅckt
'     IF BTST(ks&,3)  : Alternate-Taste gedrÅckt
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
' ---------------------------------------------------------------------------   !ÍÍFVW:textlistÍÍ
' Textlist-Wrinkle:     (Ω1997 by Holger Herzog)                                !ÍÍFVW:textlistÍÍ
'                                                                               !ÍÍFVW:textlistÍÍ
' Call textlist_click to handle mouseclicks in textlist-userwindows.            !ÍÍFVW:textlistÍÍ
'                                                                               !ÍÍFVW:textlistÍÍ
' LOCAL dd!                                                                     !ÍÍFVW:textlistÍÍ
' SELECT userhandle&                                                            !ÍÍFVW:textlistÍÍ
' CASE xxx                                                                      !ÍÍFVW:textlistÍÍ
'  LET dd!=TRUE        ! allow drag&drop                                        !ÍÍFVW:textlistÍÍ
'  LET selected&=@textlist_click(index&,mx&,my&,mb&,ks&,mc&,dd!,num%,selected!(),hash&())       !ÍÍFVW:textlistÍÍ
'  IF selected&=>0                                                              !ÍÍFVW:textlistÍÍ
'    ' Doubleclick!                                                             !ÍÍFVW:textlistÍÍ
'  ENDIF                                                                        !ÍÍFVW:textlistÍÍ
' ENDSELECT                                                                     !ÍÍFVW:textlistÍÍ
'                                                                               !ÍÍFVW:textlistÍÍ
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN
> PROCEDURE user_keyb(handle&,userhandle&,index&,ks&,key&)
'
' Diese Routine wird aufgerufen, wenn ein Tastendruck erfolgte, der
' von der faceVALUE-Engine nicht automatisch verarbeitet werden konnte.
'
' <handle&>     enthÑlt die AES-Kennung des obersten Fensters
' <userhandle&> enthÑlt die Benutzerkennung des Fensters
'               (0 falls das oberste Fenster kein Userfenster ist!)
' <index&>      enthÑlt den Index des Fensters in window_array&(index&,x)
'               (-1 falls das oberste Fenster kein Userfenster ist!)
' <ks&>         der Status der Tastaturumschalttasten
'     IF AND(ks&,&X11): Shift-Taste gedrÅckt (eine oder beide)
'     IF BTST(ks&,2)  : Control-Taste gedrÅckt
'     IF BTST(ks&,3)  : Alternate-Taste gedrÅckt
' <key&>        ASCII- und Scancode der Taste
'     BYTE(SHR(key&,8)): Scancode
'     BYTE(key&)       : ASCII-Code
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN
> FUNCTION user_win_close_ok(index&,userhandle&)
$F%
'
' Der Benutzer mîchte ein Userfenster schlieûen.
'
' <index&>      enthÑlt den Index des Fensters in window_array&(index&,x)
' <userhandle&> enthÑlt die Benutzerkennung des Fensters
'
' RÅckgabe-Werte: TRUE  um das Fenster zu schlieûen
'                 FALSE um den Wunsch zu ignorieren
'
' Normalerweise sollte der Benutzer gefragt werden, ob er das Fenster
' wirklich schlieûen mîchte. Die Programmzeilen in dieser Funktion sind
' nur als Beispiel gedacht.
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
IF userhandle&=messagewin_userhandle_&                          !ÍÍFVW:messagewinÍÍ
  @messagewin_close                                             !ÍÍFVW:messagewinÍÍ
  RETURN TRUE                                                   !ÍÍFVW:messagewinÍÍ
ENDIF                                                           !ÍÍFVW:messagewinÍÍ
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
SELECT FORM_ALERT(1,"[2][Wirklich schlieûen? ][ OK |Abbruch]")
CASE 1
RETURN TRUE
CASE 2
RETURN FALSE
ENDSELECT
'
ENDFUNC
> PROCEDURE user_gem_messages(mx&,my&,ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
'
' Jede AES-Mitteilung, die von der faceVALUE-Engine nicht ausgewertet
' wurde, wird an diese Routine Åbergeben. An dieser Stelle kînnen daher
' eigene oder standarisierte Protokolle implementiert werden. Die
' Nachrichten kînnen aber ebenso auch komplett ignoriert werden.
'
' <mx&> und <my&> enthalten die Mauskoordinaten beim Eintreffen der
'       Mitteilung
' <ks&> enthÑlt den Status der Tastaturumschalttasten beim Eintreffen
'       der Mitteilung
' <m0&> bis <m7&> enthalten die Datenwîrter der AES-Nachricht
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN
> FUNCTION user_quit_ok
$F%
exit_program!=FALSE
IF acc!
RETURN TRUE
ELSE
'
' Der Benutzer mîchte das Programm verlassen.
'
' RÅckgabe-Werte: TRUE  zum Beenden
'                 FALSE um den Wunsch zu ignorieren
'
' Normalerweise sollte beim Benutzer nachgefragt werden, ob er das
' Programm wirklich verlassen mîchte.
'
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN TRUE
'
ENDIF
ENDFUNC
> PROCEDURE user_win_close_all
'
' Dieses Unterprogramm wird aufgerufen, wenn die Routine WIN_CLOSE_ALL
' abgewickelt wird, und zwar bevor alle Fenster geschlossen werden und
' die Fenster-Arrays gelîscht werden.
'
' Wenn irgendwelche speziellen Resourcen mit den Fenstern verknÅpft sind,
' kînnen diese hier freigegeben werden.
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
@messagewin_close                                                       !ÍÍFVW:messagewinÍÍ
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN
> PROCEDURE user_on_exit
'
' Dieses Unterprogramm wird aufgerufen, wenn das Programm verlassen wird.
' Falls globale Resourcen freigegeben werden mÅssen, kann dies hier getan
' werden.
'
' Wenn das Programm als Accessory lÑuft, wird diese Routine JEDESMAL
' aufgerufen, wenn das ACCESSORY GESCHLOSSEN WIRD.
' (Hinweis: Ein Accessory wird NIE wirklich beendet.)
'
  ' ÍÍwsnippetÍÍ  - Wrinkle-Code: (dieses Flag nicht lîschen oder verÑndern)
@messagewin_close                                                       !ÍÍFVW:messagewinÍÍ
  ' ÍÍwsnippetÍÍ  - Ende des Wrinkle-Codes: (dieses Flag nicht lîschen oder verÑndern)
'
RETURN
'
' ------------------------------------------------------------------------
' WRINKLE-Callback-Routinen: bei Bedarf ausfÅllen ...
'
> PROCEDURE user_textlist_dragdrop(source&,dest&,dx&,dy&)
'
' written on 25.09.1996 by Holger Herzog
'
' Version 1.1
'
' This procedure is called if the user has moved one or a few entries
' of a textlist-window by drag and drop. Be advised that source- and
' destinationwindow could be same.
'
'     source&                 ==> FV-Index of source-window
'     dest&                   ==> FV-Index of destination-window
'     dx&, dy&                ==> position (in pixels) where the user has
'                                 dopped the entries (realtive to the left
'                                 upper corner of the destination-window)
'
' Version 1.0         27.09.1996 Holger Herzog
' Version 1.1         29.03.1997 Holger Herzog
'                     Docu now in english :-)
'
' LOCAL source_handle&,source_userhandle&
' LOCAL dest_handle&,dest_userhandle&
' LOCAL off_x&,off_y&
'
' LET source_handle&=window_array&(source&,0)
' LET source_userhandle&=window_array&(source&,8)
' LET dest_handle&=window_array&(dest&,0)
' LET dest_userhandle&=window_array&(dest&,8)
' LET off_x&=window_array&(dest&,10)
' LET off_y&=window_array&(dest&,11)
'
'
RETURN
'
' ------------------------------------------------------------------------
' ÍÍ_system_ÍÍ - SYSTEM: - Nicht verÑndern! '!call'-Routinen kînnen aufgerufen werden.
'
>PROCEDURE init
LOCAL a&
LET current_menutitle&=-1
LET top_modal&=-1
LET rsc_path_name$="EASYMINT.rsc"
LET max_number_windows&=4         ! +SYM
LET window_array_size&=25     ! +SYM
LET windowtree_array_size&=5     ! +SYM 
DIM window_array&(max_number_windows&,window_array_size&)
DIM window_tree%(max_number_windows&,windowtree_array_size&)
  DIM fvrc_evnt&(12)
  LET fv_aes_timer!=FALSE
  FOR a&=0 TO max_number_windows&
    LET window_array&(a&,21)=-1
  NEXT a&
LET gdos_minimum&=0          ! +SYM
LET num_prgdef_objects&=46          ! +SYM
LET last_tree&=16          ! +SYM
LET no_rsc_found$="[3][ |RSC-File nicht gefunden! ][ Abbruch ]"
LET not_accessory$="[3][ |This is not an accessory! ][  OK  ]"
LET systemcheck_alert$="[3][ |System requirements not met. ][ Abort ]"
'
'
' ++SYM
'
'
' ---------------------------------------------------------------------------
' Globale RSC-Datei Variablen:
  LET system&=0
  LET fvt_asci&=1
  LET fvt_alst&=2
  LET fvt_work&=3
  LET fvt_prog&=4
  LET fvt_popu&=5
  LET fvt_maus&=6
  LET about&=7
  LET mainmenu&=8
  LET pre&=9
  LET pfade&=10
  LET message&=11
  LET message2&=12
  LET startprg&=13
  LET nic&=14
  LET ppp&=15
  LET preinst&=16
  LET lw_c&=29
  LET lw_d&=30
  LET lw_e&=31
  LET lw_f&=32
  LET lw_g&=33
  LET lw_h&=34
  LET lw_i&=35
  LET lw_j&=36
  LET lw_k&=37
  LET lw_l&=38
  LET lw_m&=39
  LET lw_n&=40
  LET lw_o&=41
  LET lw_p&=42
  LET lw_q&=43
  LET lw_r&=44
  LET lw_s&=45
  LET lw_t&=46
  LET lw_u&=47
  LET lw_v&=48
  LET lw_w&=49
  LET lw_x&=50
  LET lw_y&=51
  LET lw_z&=52
  LET lw_1&=53
  LET lw_2&=54
  LET lw_3&=55
  LET lw_4&=56
  LET lw_5&=57
  LET lw_6&=58
  LET ext_c&=60
  LET ext_d&=61
  LET ext_e&=62
  LET ext_f&=63
  LET ext_g&=64
  LET ext_h&=65
  LET ext_i&=66
  LET ext_j&=67
  LET ext_k&=68
  LET ext_l&=69
  LET ext_m&=70
  LET ext_n&=71
  LET ext_o&=72
  LET ext_p&=73
  LET ext_q&=74
  LET ext_r&=75
  LET ext_s&=76
  LET ext_t&=77
  LET ext_u&=78
  LET ext_v&=79
  LET ext_w&=80
  LET ext_x&=81
  LET ext_y&=82
  LET ext_z&=83
  LET ext_1&=84
  LET ext_2&=85
  LET ext_3&=86
  LET ext_4&=87
  LET ext_5&=88
  LET ext_6&=89
  LET smilemouse&=2
  LET version1&=3
  LET version2&=5
  LET version3&=6
  LET version4&=7
  LET version5&=8
  LET aboutok&=9
  LET mm_about&=7
  LET mm_quit&=16
  LET pre_info&=2
  LET pakete&=4
  LET net&=5
  LET devel&=6
  LET libs&=7
  LET x11&=8
  LET rpmsja&=10
  LET filecheck&=12
  LET shutdown&=13
  LET mico&=14
  LET preabbr&=15
  LET preok&=16
  LET pf_info&=2
  LET login&=4
  LET naes_drkt&=5
  LET xaaesstrt&=6
  LET plaintos&=7
  LET naespfad&=10
  LET naescar&=11
  LET xaaespfad&=14
  LET pathabbr&=15
  LET pathok&=16
  LET mes1&=2
  LET mes2&=3
  LET mes3&=4
  LET mes4&=5
  LET mes5&=6
  LET mes6&=7
  LET mes7&=8
  LET infoabbr&=9
  LET mes_ok&=10
  LET mes1_00&=2
  LET mes2_00&=3
  LET mes3_00&=4
  LET mes4_00&=5
  LET mes5_00&=6
  LET mes6_00&=7
  LET mes7_00&=8
  LET inf2abbr&=9
  LET mes_ok_00&=10
  LET appname&=2
  LET nic_info&=2
  LET kuerzel&=4
  LET ipadr&=6
  LET netmask&=8
  LET defaultr&=9
  LET gateway&=10
  LET dns&=12
  LET domain&=13
  LET domaine&=14
  LET hn&=16
  LET nw_abbr&=17
  LET nw_ok&=18
  LET ispname&=3
  LET ppp_info&=4
  LET atz&=6
  LET timeout&=8
  LET device&=10
  LET speed&=13
  LET ispnumber&=16
  LET user&=18
  LET passwd&=20
  LET nameserver&=22
  LET pppdomain&=24
  LET localip&=28
  LET remoteip&=30
  LET ppp_abbr&=31
  LET ppp_ok&=32
  LET preinfo&=2
  LET compi&=4
  LET boot&=7
  LET ext2&=10
  LET pabbr&=12
  LET pok&=13
'
' ++SYM
'
RETURN
>FUNCTION systemcheck
  $F%
  LOCAL ok!
  ok!=TRUE
IF ok!=FALSE
~FORM_ALERT(1,systemcheck_alert$)
ELSE
ok!=@user_systemcheck
ENDIF
RETURN ok!
ENDFUNC
>PROCEDURE rsc_setup_tree(tree&)                                   !call
  SELECT tree&
  CASE fvt_popu&
      @rsc_set_selectable(tree&,lw_c&,lw_c_var!)
      @rsc_set_selectable(tree&,lw_d&,lw_d_var!)
      @rsc_set_selectable(tree&,lw_e&,lw_e_var!)
      @rsc_set_selectable(tree&,ext_c&,ext_c_var!)
      @rsc_set_selectable(tree&,ext_d&,ext_d_var!)
      @rsc_set_selectable(tree&,ext_e&,ext_e_var!)
  CASE pre&
      @rsc_set_selectable(tree&,pakete&,pakete_var!)
      @rsc_set_selectable(tree&,net&,net_var!)
      @rsc_set_selectable(tree&,devel&,devel_var!)
      @rsc_set_selectable(tree&,libs&,libs_var!)
      @rsc_set_selectable(tree&,x11&,x11_var!)
      @rsc_set_selectable(tree&,rpmsja&,rpmsja_var!)
      @rsc_set_selectable(tree&,filecheck&,filecheck_var!)
      @rsc_set_selectable(tree&,shutdown&,shutdown_var!)
      @rsc_set_selectable(tree&,mico&,mico_var!)
  CASE pfade&
      @rsc_set_radio(tree&,login&,login_var&,-1)
      @rsc_set_text(tree&,naespfad&,naespfad_var$)
      @rsc_set_selectable(tree&,naescar&,naescar_var!)
      @rsc_set_text(tree&,xaaespfad&,xaaespfad_var$)
  CASE nic&
      @rsc_set_text(tree&,kuerzel&,kuerzel_var$)
      @rsc_set_text(tree&,ipadr&,ipadr_var$)
      @rsc_set_text(tree&,netmask&,netmask_var$)
      @rsc_set_text(tree&,gateway&,gateway_var$)
      @rsc_set_text(tree&,dns&,dns_var$)
      @rsc_set_text(tree&,domaine&,domaine_var$)
      @rsc_set_text(tree&,hn&,hn_var$)
  CASE ppp&
      @rsc_set_text(tree&,ispname&,ispname_var$)
      @rsc_set_text(tree&,atz&,atz_var$)
      @rsc_set_text(tree&,timeout&,timeout_var$)
      @popup_set_selected(tree&,device&,device_var&,-1)
      @popup_set_selected(tree&,speed&,speed_var&,-1)
      @rsc_set_text(tree&,ispnumber&,ispnumber_var$)
      @rsc_set_text(tree&,user&,user_var$)
      @rsc_set_text(tree&,passwd&,passwd_var$)
      @rsc_set_text(tree&,nameserver&,nameserver_var$)
      @rsc_set_text(tree&,pppdomain&,pppdomain_var$)
      @rsc_set_text(tree&,localip&,localip_var$)
      @rsc_set_text(tree&,remoteip&,remoteip_var$)
  CASE preinst&
      @popup_set_selected(tree&,compi&,compi_var&,-1)
      @popup_set_selected(tree&,boot&,boot_var&,-1)
      @popup_set_selected(tree&,ext2&,ext2_var&,-1)
  ENDSELECT
RETURN
>PROCEDURE rsc_read_tree(tree&,object&)
  SELECT tree&
  CASE fvt_popu&
    SELECT object&
    CASE lw_c&
      LET lw_c_var!=@rsc_get_selectable(tree&,object&)
    CASE lw_d&
      LET lw_d_var!=@rsc_get_selectable(tree&,object&)
    CASE lw_e&
      LET lw_e_var!=@rsc_get_selectable(tree&,object&)
    CASE ext_c&
      LET ext_c_var!=@rsc_get_selectable(tree&,object&)
    CASE ext_d&
      LET ext_d_var!=@rsc_get_selectable(tree&,object&)
    CASE ext_e&
      LET ext_e_var!=@rsc_get_selectable(tree&,object&)
    ENDSELECT
  CASE pre&
    SELECT object&
    CASE pakete&
      LET pakete_var!=@rsc_get_selectable(tree&,object&)
    CASE net&
      LET net_var!=@rsc_get_selectable(tree&,object&)
    CASE devel&
      LET devel_var!=@rsc_get_selectable(tree&,object&)
    CASE libs&
      LET libs_var!=@rsc_get_selectable(tree&,object&)
    CASE x11&
      LET x11_var!=@rsc_get_selectable(tree&,object&)
    CASE rpmsja&
      LET rpmsja_var!=@rsc_get_selectable(tree&,object&)
    CASE filecheck&
      LET filecheck_var!=@rsc_get_selectable(tree&,object&)
    CASE shutdown&
      LET shutdown_var!=@rsc_get_selectable(tree&,object&)
    CASE mico&
      LET mico_var!=@rsc_get_selectable(tree&,object&)
    ENDSELECT
  CASE pfade&
    SELECT object&
    CASE login&,5,6,7
      LET login_var&=@rsc_get_radio(tree&,object&)
    CASE naespfad&
      LET naespfad_var$=@rsc_get_text$(tree&,object&)
    CASE naescar&
      LET naescar_var!=@rsc_get_selectable(tree&,object&)
    CASE xaaespfad&
      LET xaaespfad_var$=@rsc_get_text$(tree&,object&)
    ENDSELECT
  CASE nic&
    SELECT object&
    CASE kuerzel&
      LET kuerzel_var$=@rsc_get_text$(tree&,object&)
    CASE ipadr&
      LET ipadr_var$=@rsc_get_text$(tree&,object&)
    CASE netmask&
      LET netmask_var$=@rsc_get_text$(tree&,object&)
    CASE gateway&
      LET gateway_var$=@rsc_get_text$(tree&,object&)
    CASE dns&
      LET dns_var$=@rsc_get_text$(tree&,object&)
    CASE domaine&
      LET domaine_var$=@rsc_get_text$(tree&,object&)
    CASE hn&
      LET hn_var$=@rsc_get_text$(tree&,object&)
    ENDSELECT
  CASE ppp&
    SELECT object&
    CASE ispname&
      LET ispname_var$=@rsc_get_text$(tree&,object&)
    CASE atz&
      LET atz_var$=@rsc_get_text$(tree&,object&)
    CASE timeout&
      LET timeout_var$=@rsc_get_text$(tree&,object&)
    CASE device&
      LET device_var&=@popup_get_radio(tree&,object&)
    CASE speed&
      LET speed_var&=@popup_get_radio(tree&,object&)
    CASE ispnumber&
      LET ispnumber_var$=@rsc_get_text$(tree&,object&)
    CASE user&
      LET user_var$=@rsc_get_text$(tree&,object&)
    CASE passwd&
      LET passwd_var$=@rsc_get_text$(tree&,object&)
    CASE nameserver&
      LET nameserver_var$=@rsc_get_text$(tree&,object&)
    CASE pppdomain&
      LET pppdomain_var$=@rsc_get_text$(tree&,object&)
    CASE localip&
      LET localip_var$=@rsc_get_text$(tree&,object&)
    CASE remoteip&
      LET remoteip_var$=@rsc_get_text$(tree&,object&)
    ENDSELECT
  CASE preinst&
    SELECT object&
    CASE compi&
      LET compi_var&=@popup_get_radio(tree&,object&)
    CASE boot&
      LET boot_var&=@popup_get_radio(tree&,object&)
    CASE ext2&
      LET ext2_var&=@popup_get_radio(tree&,object&)
    ENDSELECT
  ENDSELECT
RETURN
> FUNCTION get_rsc
$F%
LOCAL ret%
~@appl_xgetinfo(2,gout1&,gout2&,gout3&,gout4&)
IF gout3&=1 AND gout4&=1
LET ret%=RSRC_LOAD(rsc_path_name$)
CLR rsc_handle%
ELSE
LET ret%=@xrsrc_load(rsc_path_name$)
LET rsc_handle%=ret%
ENDIF
RETURN ret%
ENDFUNC
> PROCEDURE cleanup_after_rsc
IF rsc_handle%=0
~RSRC_FREE()
ELSE
~@xrsrc_free(rsc_handle%)
CLR rsc_handle%
ENDIF
RETURN
> FUNCTION xrsrc_gaddr(type&,tree&)                                       !call
$F%
LOCAL tree%
IF rsc_handle%=0
~RSRC_GADDR(type&,tree&,tree%)
ELSE IF NOT (rsc_handle%>=0 AND rsc_handle%<1024)
~@xrsrc_xgaddr(rsc_handle%,type&,tree&,tree%)
ENDIF
RETURN tree%
ENDFUNC
> FUNCTION win_snap(x&)
$F%
IF snap_windows!
RETURN SUB(x&,MOD(x&,16))
ENDIF
RETURN x&
ENDFUNC
> PROCEDURE win_place_tree(handle&)
LOCAL x&,y&,d&
LOCAL index&
~WIND_GET(handle&,4,x&,y&,d&,d&)
LET index&=@win_get_index(handle&)
OB_X(window_tree%(index&,0),0)=SUB(x&,window_array&(index&,15))
OB_Y(window_tree%(index&,0),0)=y&
RETURN
> PROCEDURE win_close_all                                                 !call
LOCAL a&,b&
@user_win_close_all
IF @win_modal_enq
@disable_menus(0)
top_modal&=-1
ENDIF
FOR a&=0 TO max_number_windows&
IF window_array&(a&,0)>0
~WIND_CLOSE(window_array&(a&,0))
~WIND_DELETE(window_array&(a&,0))
FOR b&=0 TO window_array_size&
window_array&(a&,b&)=0
NEXT b&
FOR b&=0 TO windowtree_array_size&
window_tree%(a&,b&)=0
NEXT b&
window_array&(a&,21)=-1
ENDIF
NEXT a&
RETURN
> PROCEDURE win_close(handle&)                                            !call
LOCAL index&,type!,a&,prev_top&
IF handle&>0
index&=@win_get_index(handle&)
IF index&<>-1
IF top_modal&<>-1 AND index&<>top_modal&
~GEMDOS(2,7)
ELSE
~WIND_CLOSE(handle&)
~WIND_DELETE(handle&)
IF window_array&(index&,1)=1 OR window_array&(index&,1)=4
type!=TRUE
prev_top&=window_array&(index&,6)
ELSE IF window_array&(index&,1)=0 AND window_array&(index&,24)=0
type!=TRUE
prev_top&=window_array&(index&,25)
ENDIF
FOR a&=0 TO window_array_size&
window_array&(index&,a&)=0
NEXT a&
window_array&(index&,21)=-1
FOR a&=0 TO windowtree_array_size&
window_tree%(index&,a&)=0
NEXT a&
IF type!
IF NOT @win_modal_enq
@disable_menus(0)
top_modal&=-1
ELSE
top_modal&=prev_top&
~WIND_SET(window_array&(top_modal&,0),10,0,0,0,0)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
> PROCEDURE win_set_title(index&,title$)                                  !call
LOCAL adr%
IF LEN(title$)>78
title$=LEFT$(title$,78)
ENDIF
title$=title$+CHR$(0)
adr%=window_tree%(index&,1)
BMOVE V:title$,adr%,LEN(title$)
~WIND_SET(window_array&(index&,0),2,CARD(SWAP(adr%)),CARD(adr%),0,0)
RETURN
> FUNCTION win_open_dialog(type&,tree&,icon&)                             !call
$F%
RETURN @win_open_dialog2(type&,tree&,icon&,FALSE)
ENDFUNC
> FUNCTION win_open_dialog2(type&,tree&,icon&,ic!)
$F%
LOCAL handle&,kind&,x&,y&,w&,h&,index&,tree%,dx&,dy&,dw&,dh&,d&
LOCAL ob_backgr&
tree%=@xrsrc_gaddr(0,tree&)
index&=@find_free_w_array
IF index&<>-1
IF @find_handle_from_tree(tree&)=-1
SELECT type&
CASE -1
SELECT BYTE(SHR&(OB_TYPE(tree%,0),8))
CASE 18 !non modal
type&=2
kind&=&X1011
CASE 19 !prg modal
type&=1
kind&=&X1001
CASE 20 !toolbox
type&=3
kind&=&X1001
DEFAULT !non modal
type&=2
kind&=&X1011
ENDSELECT
CASE 1,3
kind&=&X1001
CASE 2,4
kind&=&X1011
CASE 5
type&=1
kind&=&X1011
CASE 6
type&=3
kind&=&X1011
CASE 7
type&=1
kind&=0
CASE 8
type&=2
kind&=0
CASE 9
type&=3
kind&=0
ENDSELECT
IF icon&<>-1 AND type&<>1 AND type&<>4 AND kind&<>0
kind&=kind& OR &X100000000000000
ENDIF
ob_backgr&=0
~WIND_CALC(0,kind&,OB_X(tree%,0),OB_Y(tree%,0),OB_W(tree%,ob_backgr&),OB_H(tree%,ob_backgr&),x&,y&,w&,h&)
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
IF x&<dx& OR y&<dy& OR x&+w&>dx&+dw& OR y&+h&>dy&+dh&
~FORM_CENTER(tree%,d&,d&,d&,d&)
~WIND_CALC(0,kind&,OB_X(tree%,0),OB_Y(tree%,0),OB_W(tree%,ob_backgr&),OB_H(tree%,ob_backgr&),x&,y&,w&,h&)
y&=MAX(y&,dy&)
ENDIF
handle&=WIND_CREATE(kind&,x&,y&,w&,h&)
IF handle&>0
window_array&(index&,0)=handle&
window_array&(index&,1)=type&
window_array&(index&,2)=@first_gftext(tree%)
IF window_array&(index&,2)>0
window_array&(index&,3)=LEN(CHAR{{OB_SPEC(tree%,window_array&(index&,2))}})
ELSE
window_array&(index&,3)=0
ENDIF
window_array&(index&,4)=tree&
window_array&(index&,5)=icon&
window_array&(index&,6)=-1
window_array&(index&,7)=kind&
window_tree%(index&,0)=tree%
window_tree%(index&,1)=ADD(system_pool%,MUL(index&,160))
IF OB_TYPE(tree%,1)=28 AND kind&<>0
OB_FLAGS(tree%,1)=BSET(OB_FLAGS(tree%,1),7)
@win_set_title(index&,CHAR{OB_SPEC(tree%,1)})
ELSE
@win_set_title(index&,CHR$(0))
ENDIF
IF icon&<>-1
tree%=@xrsrc_gaddr(0,icon&)
window_tree%(index&,2)=tree%
ELSE
window_tree%(index&,2)=0
ENDIF
x&=@win_snap(x&)
IF type&=1 AND tree&=fvt_prog&            !***progress snap to 4
y&=MAX(MUL(DIV(ADD(y&,2),4),4),dy&)
IF NOT snap_windows!
x&=MUL(DIV(ADD(x&,2),4),4)
ENDIF
ENDIF
~WIND_OPEN(handle&,x&,y&,w&,h&)
IF type&=1 OR type&=4
@disable_menus(-1)
IF top_modal&>-1
window_array&(index&,6)=top_modal&
ENDIF
top_modal&=index&
ENDIF
RETURN handle&
ELSE
~@alert_standard(1,2,"")
RETURN 0
ENDIF
ELSE
~WIND_SET(@find_handle_from_tree(tree&),10,0,0,0,0)
RETURN @find_handle_from_tree(tree&)
ENDIF
ELSE
~@alert_standard(1,2,"")
RETURN 0
ENDIF
ENDFUNC
> PROCEDURE win_close_dialog(tree&)                                       !call
@win_close(@find_handle_from_tree(tree&))
RETURN
> FUNCTION win_get_index(handle&)                                         !call
$F%
LOCAL a&
FOR a&=0 TO max_number_windows&
IF handle&=window_array&(a&,0) AND window_array&(a&,4)<>0
RETURN a&
ENDIF
NEXT a&
RETURN -1
ENDFUNC
> PROCEDURE win_send_redraw(index&,x&,y&,w&,h&)                           !call
IF x&=-1 AND y&=-1 AND w&=-1 AND h&=-1 AND window_array&(index&,0)<>0
~WIND_GET(window_array&(index&,0),4,x&,y&,w&,h&)
ENDIF
IF window_array&(index&,0)=0
~FORM_DIAL(3,0,0,0,0,x&,y&,w&,h&)
ELSE
@aes_internal_message(20,window_array&(index&,0),x&,y&,w&,h&)
ENDIF
RETURN
> FUNCTION win_modal_enq                                                  !call
$F%
LOCAL a&
FOR a&=0 TO max_number_windows&
IF window_array&(a&,1)=1 OR window_array&(a&,1)=4
RETURN TRUE
ELSE IF window_array&(a&,1)=0 AND window_array&(a&,24)=0 AND window_array&(a&,0)>0
RETURN TRUE
ENDIF
NEXT a&
RETURN FALSE
ENDFUNC
> PROCEDURE call_st_guide(filename$,page$)                                !call
LOCAL cmd$
IF page$<>""
cmd$="*:\"+filename$+" "+page$
ELSE
cmd$="*:\"+filename$
ENDIF
~@program_start("ST-GUIDE","STGUIDE","",cmd$,cmd$,"","",0)
RETURN
> PROCEDURE v_clsvwk(handle&)                                             !call
CONTRL(0)=101
CONTRL(1)=0
CONTRL(3)=0
CONTRL(6)=handle&
VDISYS 101,0,0
RETURN
> FUNCTION get_cookie(cookie$,VAR value%)                                 !call
$F%
LOCAL cookie%,cookie!,such%,found%,ret%
CLR cookie!
LET such%=CVL(cookie$)
LET ret%=GEMDOS(340,8,L:such%,L:V:value%)
IF ret%=-32
cookie%=BIOS(5,&H5A0\4,L:-1)
IF cookie%<>0
DO
LET found%={cookie%}
EXIT IF found%=0
IF found%=such%
LET cookie!=TRUE
LET value%={cookie%+4}
EXIT IF TRUE
ENDIF
ADD cookie%,8
LOOP
ENDIF
ELSE
LET cookie!=(ret%<>-1)
ENDIF
RETURN cookie!
ENDFUNC
> FUNCTION alert_standard(default&,index&,insert$)                        !call
$F%
LOCAL tree%
tree%=@xrsrc_gaddr(0,fvt_alst&)
RETURN FORM_ALERT(default&,@insert_in_string$(CHAR{OB_SPEC(tree%,index&)},insert$))
ENDFUNC
> PROCEDURE rsc_ob_draw(index&,object&)                                   !call
LOCAL x&,y&,w&,h&,x1&,y1&,w1&,h1&,ob_only!
LOCAL rx&,ry&,rw&,rh&
LOCAL dx&,dy&,dw&,dh&
LET ob_only!=(object&<0)
LET object&=ABS(object&)
IF window_array&(index&,21)<>-1 AND (NOT ob_only!)
@win_send_redraw(index&,-1,-1,-1,-1)
ELSE
@rsc_ob_xywh(window_tree%(index&,0),object&,x&,y&,w&,h&)
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6) AND @ob_state(window_array&(index&,4),object&,12)
IF BYTE(OB_TYPE(window_tree%(index&,0),object&))=30
@rsc_ob_xywh(window_tree%(index&,0),MAX(SUB(object&,2),0),x&,y&,w&,h&)
ENDIF
ENDIF
~WIND_GET(window_array&(index&,0),4,x1&,y1&,w1&,h1&)
IF RC_INTERSECT(x1&,y1&,w1&,h1&,x&,y&,w&,h&)
IF window_array&(index&,1)>0 AND window_array&(index&,2)=object& AND (NOT ob_only!)
@win_send_redraw(index&,x&,SUB(y&,5),w&,ADD(h&,10))
ELSE
@aes_screen_lock_only_screen
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
~WIND_GET(window_array&(index&,0),11,rx&,ry&,rw&,rh&)
WHILE rw& OR rh&
IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
IF ob_only!
~OBJC_DRAW(window_tree%(index&,0),object&,7,rx&,ry&,rw&,rh&)
ELSE
~OBJC_DRAW(window_tree%(index&,0),0,7,rx&,ry&,rw&,rh&)
ENDIF
CLIP rx&,ry&,rw&,rh& OFFSET 0,0
@user_rsc_draw_extra(-1,index&,window_array&(index&,4),window_tree%(index&,0),rx&,ry&,rw&,rh&)
CLIP OFF
ENDIF
ENDIF
~WIND_GET(window_array&(index&,0),12,rx&,ry&,rw&,rh&)
WEND
@aes_screen_unlock_only_screen
ENDIF
ENDIF
ENDIF
RETURN
> FUNCTION v_opnvwk                                                       !call
$F%
LOCAL d&
CONTRL(0)=100
CONTRL(1)=0
CONTRL(3)=11
CONTRL(6)=GRAF_HANDLE(d&,d&,d&,d&)
INTIN(0)=1  ! (aktuelle Auflîsung) XBIOS(4)+2
FOR d&=1 TO 9
INTIN(d&)=1
NEXT d&
INTIN(10)=2
VDISYS 100,11,0
RETURN CONTRL(6)
ENDFUNC
> PROCEDURE rsc_ob_xywh(tree%,object&,VAR x&,y&,w&,h&)                    !call
LOCAL b&
~OBJC_OFFSET(tree%,object&,x&,y&)
w&=OB_W(tree%,object&)
h&=OB_H(tree%,object&)
SELECT BYTE(OB_TYPE(tree%,object&))
CASE 20,25,27
b&=SUB(BYTE(SHR(OB_SPEC(tree%,object&),16)),256)
IF b&<-100
b&=0
ENDIF
CASE 22,30
b&=WORD{ADD(OB_SPEC(tree%,object&),22)}
CASE 26
b&=-1
IF BTST(OB_FLAGS(tree%,object&),0) AND BTST(OB_FLAGS(tree%,object&),2)
DEC b&
ENDIF
IF BTST(OB_FLAGS(tree%,object&),0) AND BTST(OB_FLAGS(tree%,object&),1) AND BTST(OB_FLAGS(tree%,object&),2)
DEC b&
ENDIF
ENDSELECT
IF b&<0
x&=ADD(x&,b&)
y&=ADD(y&,b&)
w&=ADD(w&,MUL(-b&,2))
h&=ADD(h&,MUL(-b&,2))
ENDIF
RETURN
> PROCEDURE aes_internal_message(m0&,m3&,m4&,m5&,m6&,m7&)                 !call
@aes_send_message(ap_id&,m0&,m3&,m4&,m5&,m6&,m7&)
RETURN
> FUNCTION vq_extnd(handle&,mode&,parameter&)                             !call
$F%
CONTRL(0)=102
CONTRL(1)=0
CONTRL(2)=6
CONTRL(3)=1
CONTRL(4)=45
CONTRL(6)=handle&
INTIN(0)=mode&
VDISYS
IF parameter&<45
RETURN INTOUT(parameter&)
ELSE
RETURN PTSOUT(parameter&-45)
ENDIF
ENDFUNC
> FUNCTION vq_vgdos                                                       !call
$F%
LOCAL a%,ret&,vq_vgdos%
vq_vgdos%=faceval_sys%+2844
a%=C:vq_vgdos%()
IF WORD(a%)=-2
ret&=0
ELSE IF MKL$(a%)="_FNT"
ret&=2
ELSE IF MKL$(a%)="_FSM"
ret&=3
ELSE
ret&=1
ENDIF
RETURN ret&
ENDFUNC
> PROCEDURE mouse_wait                                                    !call
LOCAL mb&,d&
DO
~GRAF_MKSTATE(d&,d&,mb&,d&)
~EVNT_TIMER(50)
LOOP UNTIL mb&=0
RETURN
> PROCEDURE mouse_wait_realtime
LOCAL mb&,d&,evnt_flags&,time&
DO
LET evnt_flags&=&X100000
LET time&=50
event&=EVNT_MULTI(evnt_flags&,256+2,3,0,0,0,0,0,0,0,0,0,0,0,0,time&,d&,d&,d&,d&,d&,d&)
~GRAF_MKSTATE(d&,d&,mb&,d&)
LOOP UNTIL mb&=0
RETURN
> FUNCTION rsc_find_menutitle(tree&,object&)                              !call
$F%
LOCAL a&,num_tit&,num&,tree%
tree%=@xrsrc_gaddr(0,tree&)
IF BYTE(OB_TYPE(tree%,object&))=28 AND object&>5
FOR a&=3 TO object&
IF BYTE(OB_TYPE(tree%,a&))=20
INC num_tit&
ENDIF
NEXT a&
IF num_tit&>0
a&=0
DO
INC a&
IF BYTE(OB_TYPE(tree%,a&))=32
INC num&
EXIT IF num&=num_tit&
ENDIF
LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
RETURN a&
ELSE
RETURN 0
ENDIF
ELSE
RETURN 0
ENDIF
ENDFUNC
> FUNCTION vsf_color(handle&,color_index&)
$F%
INTIN(0)=color_index&
CONTRL(0)=25
CONTRL(1)=0
CONTRL(3)=1
CONTRL(6)=handle&
VDISYS
RETURN INTOUT(0)
ENDFUNC
> FUNCTION dialog_shortcuts(index&,shift!,ascii|)
$F%
LOCAL ob&,regob&
LET ob&=@dialog_shortcuts_getob(index&,shift!,ascii|,regob&)
IF ob&=>0
@my_form_do2(0,index&,ob&,-1)
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ENDFUNC
> FUNCTION dialog_shortcuts_getob(index&,shift!,ascii|,VAR regobject&)
$F%
LOCAL compare$,pre$,a&,tree%,pos&,adr%,obspec%
tree%=window_tree%(index&,0)
tree&=window_array&(index&,4)
LET regobject&=-1
a&=0
IF OB_HEAD(tree%,0)<>-1
DO
INC a&
IF BTST(OB_STATE(tree%,a&),3)=0 AND BTST(OB_FLAGS(tree%,a&),7)=0 AND (BTST(OB_FLAGS(tree%,a&),0) OR BTST(OB_FLAGS(tree%,a&),6))
IF ascii|=13 AND BTST(OB_FLAGS(tree%,a&),1)
RETURN a&
ENDIF
IF BYTE(OB_TYPE(tree%,a&))=24 AND (BYTE(SHR&(OB_TYPE(tree%,a&),8))=26 OR BYTE(SHR&(OB_TYPE(tree%,a&),8))=28)
compare$=CHAR{{OB_SPEC(tree%,a&)+4}}
pre$="["+UPPER$(CHR$(ascii|))
ELSE IF BYTE(OB_TYPE(tree%,a&))=31 OR BYTE(OB_TYPE(tree%,a&))=33
compare$=CHAR{{OB_SPEC(tree%,a&)+8}}
IF shift!
pre$=""+UPPER$(CHR$(ascii|))
ELSE
IF INSTR(compare$,"")
compare$=""
ENDIF
pre$=""+UPPER$(CHR$(ascii|))
ENDIF
ELSE IF @ob_flags(tree&,a&,8)
LET pos&=SHR(OB_STATE(tree%,a&),8) AND &H7F
obspec%=ADD(faceval_sys%,INT{ADD(faceval_sys%,18)})
LET adr%=C:obspec%(L:tree%,a&)
LET compare$=CHAR{adr%}
IF pos&=>0 AND pos&<LEN(compare$)
LET compare$=UPPER$(MID$(compare$,pos&+1,1))
LET pre$=UPPER$(CHR$(ascii|))
ELSE
LET pre$="Nix"
CLR compare$
ENDIF
ENDIF
IF compare$<>""
IF INSTR(UPPER$(compare$),pre$)
RETURN a&
ENDIF
ENDIF
ENDIF
LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
ENDIF
RETURN -1
ENDFUNC
> FUNCTION help_object(tree&,tree%)
$F%
LOCAL a&
a&=0
DO
INC a&
IF @ob_flags(tree&,a&,15)
RETURN TRUE
ENDIF
LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
RETURN FALSE
ENDFUNC
> FUNCTION find_handle_from_tree(tree&)
$F%
LOCAL a&
FOR a&=0 TO max_number_windows&
IF window_array&(a&,1)>0
IF tree&=window_array&(a&,4)
RETURN window_array&(a&,0)
ENDIF
ENDIF
NEXT a&
RETURN -1
ENDFUNC
> FUNCTION first_gftext(tree%)
$F%
LOCAL obj&
obj&=-1
REPEAT
INC obj&
IF BTST(OB_FLAGS(tree%,obj&),3)
IF NOT BTST(OB_FLAGS(tree%,obj&),7)
IF NOT BTST(OB_STATE(tree%,obj&),3)
RETURN obj&
ENDIF
ENDIF
ENDIF
UNTIL BTST(OB_FLAGS(tree%,obj&),5)
RETURN 0
ENDFUNC
> FUNCTION find_free_w_array
$F%
LOCAL a&
FOR a&=0 TO max_number_windows&
IF window_array&(a&,0)=0 AND window_array&(a&,4)=0
RETURN a&
ENDIF
NEXT a&
RETURN -1
ENDFUNC
> FUNCTION insert_in_string$(a$,insert$)
LOCAL parse&
parse&=INSTR(a$,"@")
IF parse&<>0
a$=LEFT$(a$,parse&-1)+insert$+RIGHT$(a$,LEN(a$)-parse&)
ELSE
parse&=INSTR(a$,"~")
IF parse&<>0
a$=LEFT$(a$,parse&-1)+insert$+RIGHT$(a$,LEN(a$)-parse&)
ENDIF
ENDIF
RETURN a$
ENDFUNC
> FUNCTION pointforward_object(index&,object&)
$F%
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6) AND @ob_flags(window_array&(index&,4),object&,12)
IF NOT BTST(OB_FLAGS(window_tree%(index&,0),object&),5)
RETURN TRUE
ENDIF
ENDIF
RETURN FALSE
ENDFUNC
> PROCEDURE install_prg_def_main
LOCAL wchar&,hchar&,color3d&,font_id&,font_h&,d&
~GRAF_HANDLE(wchar&,hchar&,d&,d&)
{ADD(faceval_sys%,22)}=ADD(GB,24)
INT{ADD(faceval_sys%,26)}=flydials_handle&
INT{ADD(faceval_sys%,28)}=wchar&
INT{ADD(faceval_sys%,30)}=hchar&
IF INT{{ADD(GB,4)}}>=&H340
GCONTRL(0)=48
GCONTRL(1)=4
GCONTRL(2)=3
GCONTRL(3)=0
GCONTRL(4)=0
GINTIN(0)=0
GINTIN(1)=5
GEMSYS
IF GINTOUT(0)>0
color3d&=GINTOUT(1)
ENDIF
ENDIF
IF @appl_xgetinfo(0,font_h&,font_id&,d&,d&)
IF ABS(font_id&)<>1 AND @vq_vgdos<>0               ! Anderer AES-Font...
V~H=flydials_handle&
~VST_LOAD_FONTS(0)                               ! ...Fonts laden
DEFTEXT ,,,,font_id&
DEFTEXT ,,,font_h&                               ! ...und einstellen
V~H=-1
ENDIF
ENDIF
INT{ADD(faceval_sys%,32)}=color3d&>0
INT{ADD(faceval_sys%,34)}=color3d&
@install_fv_obdata(0)
@install_prg_def_objects(0)
RETURN
> PROCEDURE install_prg_def(tree%,ob&,nr&)
LOCAL c&
IF nr&=6 AND BYTE(OB_TYPE(tree%,ob&))<>28
c&=SUCC(-BTST(OB_FLAGS(tree%,ob&),1)-BTST(OB_FLAGS(tree%,ob&),2)-BTST(OB_FLAGS(tree%,ob&),6))
IF c&>1
OB_X(tree%,ob&)=OB_X(tree%,ob&)-c&
OB_Y(tree%,ob&)=OB_Y(tree%,ob&)-c&
OB_W(tree%,ob&)=OB_W(tree%,ob&)+(c&*2)
OB_H(tree%,ob&)=SUCC(OB_H(tree%,ob&)+(c&*2))
ENDIF
ENDIF
{prgdef_adress%}=ADD(faceval_sys%,INT{ADD(faceval_sys%,SHL(PRED(nr&),1))})
{ADD(prgdef_adress%,4)}=OB_SPEC(tree%,ob&)
OB_SPEC(tree%,ob&)=prgdef_adress%
OB_TYPE(tree%,ob&)=OR(SHL&(BYTE(OB_TYPE(tree%,ob&)),8),24)
ADD prgdef_adress%,8
RETURN
> PROCEDURE install_prg_def_objects(add_tree&)
LOCAL tree%,tree&,b&,d&,hchar&,wchar&,clear_flags!
LOCAL g_swbutton!,g_popup!,whitebak!,g_shortcut!
LOCAL gout1&,gout2&,gout3&,gout4&
LOCAL ib_ytext&,ib_htext&
~GRAF_HANDLE(wchar&,hchar&,d&,d&)
~@appl_xgetinfo(13,gout1&,gout2&,gout3&,gout4&)
LET g_swbutton!=BTST(gout4&,0)
LET g_popup!=BTST(gout4&,1)
LET whitebak!=BTST(gout4&,2)
LET g_shortcut!=BTST(gout4&,3)
FOR tree&=add_tree& TO ADD(last_tree&,add_tree&)
tree%=@xrsrc_gaddr(0,tree&)
b&=-1
REPEAT
INC b&
@ob_flags(tree&,b&,8,FALSE)
LET clear_flags!=TRUE
IF BYTE(OB_TYPE(tree%,b&))=31 OR BYTE(OB_TYPE(tree%,b&))=33
LET ib_ytext&=CARD{ADD(OB_SPEC(tree%,b&),28)}
LET ib_htext&=CARD{ADD(OB_SPEC(tree%,b&),32)}
OB_H(tree%,b&)=MAX(OB_H(tree%,b&),ADD(ib_ytext&,ib_htext&))
ENDIF
IF BYTE(OB_TYPE(tree%,b&))=23
ELSE IF BYTE(OB_TYPE(tree%,b&))=31
ELSE
IF NOT @ob_state(tree&,b&,12)
@update_prg_def_textob(TRUE,tree%,tree&,b&,whitebak!,clear_flags!)
IF BYTE(SHR&(OB_TYPE(tree%,b&),8))=22
IF BYTE(OB_TYPE(tree%,b&))=27
@ob_flags(tree&,b&,9,TRUE)
IF (hchar&=8 OR hchar&=16) AND wchar&=8
@install_prg_def(tree%,b&,7)      !circlebutton
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF clear_flags!
@clear_flags(tree%,b&)
ENDIF
UNTIL BTST(OB_FLAGS(tree%,b&),5)
NEXT tree&
RETURN
> PROCEDURE update_prg_def_textob(install!,tree%,tree&,b&,whitebak!,VAR clear_flags!)
IF BYTE(OB_TYPE(tree%,b&))=26 OR BYTE(OB_TYPE(tree%,b&))=28
SELECT BYTE(SHR&(OB_TYPE(tree%,b&),8))
CASE 18
IF whitebak!
IF (BTST(OB_FLAGS(tree%,b&),4) OR BTST(OB_FLAGS(tree%,b&),0)) AND (NOT BTST(OB_FLAGS(tree%,b&),2))  ! radio/check
@install_magic_obj(tree&,tree%,b&,-2,TRUE)
CLR clear_flags!
ELSE IF BTST(OB_FLAGS(tree%,b&),2) OR BTST(OB_FLAGS(tree%,b&),6)                                    ! exit/touchexit
@install_magic_obj(tree&,tree%,b&,-2,FALSE)
CLR clear_flags!
ENDIF
ELSE
IF BTST(OB_FLAGS(tree%,b&),2)
IF install!
@install_prg_def(tree%,b&,6)      !shortcut/exit
ENDIF
CLR clear_flags!
ELSE IF BTST(OB_FLAGS(tree%,b&),4)
IF install!
@install_prg_def(tree%,b&,1)      !radiobutton/round
ENDIF
CLR clear_flags!
ELSE IF BTST(OB_FLAGS(tree%,b&),0)
IF install!
@install_prg_def(tree%,b&,2)      !selectable/checkbox
ENDIF
CLR clear_flags!
ELSE IF BTST(OB_FLAGS(tree%,b&),6)
IF install!
@install_prg_def(tree%,b&,6)      !shortcut/touchexit
ENDIF
CLR clear_flags!
ENDIF
ENDIF
CASE 19
IF whitebak!
@install_magic_obj(tree&,tree%,b&,-1,FALSE)
ELSE
IF install!
@install_prg_def(tree%,b&,4)        !underlined text
ENDIF
ENDIF
CLR clear_flags!
CASE 20
IF whitebak!
@install_magic_obj(tree&,tree%,b&,-3,FALSE)
ELSE
IF install!
@install_prg_def(tree%,b&,3)        !frame
ENDIF
ENDIF
CLR clear_flags!
CASE 21
IF install!
@install_prg_def(tree%,b&,8)        !niceline
ENDIF
CLR clear_flags!
ENDSELECT
ENDIF
RETURN
> PROCEDURE install_magic_obj(tree&,tree%,ob&,underline&,mac!)
LOCAL text$,obspec%,pos&,adr%,state|,whitebak!,wchar&,hchar&,a&
~GRAF_HANDLE(wchar&,hchar&,a&,a&)
@clear_flags(tree%,ob&)
LET whitebak!=TRUE
IF underline&=-2
obspec%=ADD(faceval_sys%,INT{ADD(faceval_sys%,18)})
LET adr%=C:obspec%(L:tree%,ob&)
LET text$=CHAR{adr%}
LET pos&=INSTR(text$,"[")
IF pos&>0
LET underline&=PRED(pos&)
CHAR{adr%}=LEFT$(text$,PRED(pos&))+MID$(text$,SUCC(pos&))
ENDIF
ENDIF
SELECT underline&
CASE -3
LET state|=BYTE(-2)
CASE -1
LET state|=255
OB_TYPE(tree%,ob&)=(OB_TYPE(tree%,ob&) AND &HFF00) OR 28
CASE 0 TO
IF mac!
LET state|=BYTE(BSET(underline& AND &H7F,7))
ELSE
LET state|=BYTE(underline& AND &H7F)
ENDIF
@ob_flags(tree&,ob&,8,TRUE)
DEFAULT
IF mac!
LET state|=BYTE(-1)
ELSE
LET state|=0
CLR whitebak!
ENDIF
ENDSELECT
IF whitebak!
OB_STATE(tree%,ob&)=BSET(OB_STATE(tree%,ob&) OR SHL(state|,8),6)
ELSE
OB_STATE(tree%,ob&)=BCLR(OB_STATE(tree%,ob&) OR SHL(state|,8),6)
ENDIF
RETURN
> PROCEDURE clear_flags(tree%,b&)
OB_STATE(tree%,b&)=OB_STATE(tree%,b&) AND &HFF
OB_FLAGS(tree%,b&)=OB_FLAGS(tree%,b&) AND &HFFF
RETURN
> PROCEDURE install_fv_obdata(add_tree&)
LOCAL tree%,tree&,b&
DIM fv_obdata_new%(ADD(last_tree&,add_tree&))
IF add_tree&=>0
FOR tree&=0 TO PRED(add_tree&)
LET fv_obdata_new%(tree&)=fv_obdata%(tree&)
NEXT tree&
ENDIF
IF DIM?(fv_obdata%())>add_tree&
LET fv_obdata$=LEFT$(fv_obdata$,fv_obdata%(add_tree&))
ELSE IF add_tree&<=0
CLR fv_obdata$
ENDIF
IF last_tree&=>0
FOR tree&=add_tree& TO ADD(last_tree&,add_tree&)
LET fv_obdata_new%(tree&)=LEN(fv_obdata$)
tree%=@xrsrc_gaddr(0,SUB(tree&,add_tree&))
b&=-1
REPEAT
INC b&
LET fv_obdata$=fv_obdata$+MKI$(WORD(BYTE(SHR&(OB_STATE(tree%,b&),8)) OR (OB_FLAGS(tree%,b&) AND &HF000)))
UNTIL BTST(OB_FLAGS(tree%,b&),5)
NEXT tree&
ENDIF
SWAP fv_obdata_new%(),fv_obdata%()
ERASE fv_obdata_new%()
RETURN
> FUNCTION ob_flags(tree&,ob&,flag&)
$F%
RETURN BTST(WORD{V:fv_obdata$+fv_obdata%(tree&)+ADD(ob&,ob&)},flag&)
ENDFUNC
> FUNCTION ob_state(tree&,ob&,flag&)
$F%
RETURN BTST(WORD{V:fv_obdata$+fv_obdata%(tree&)+ADD(ob&,ob&)},SUB(flag&,8))
ENDFUNC
> PROCEDURE ob_flags(tree&,ob&,flag&,value!)
LOCAL adr%
LET adr%=V:fv_obdata$+fv_obdata%(tree&)+ADD(ob&,ob&)
IF value!
WORD{adr%}=WORD(BSET(WORD{adr%},flag&))
ELSE
WORD{adr%}=WORD(BCLR(WORD{adr%},flag&))
ENDIF
RETURN
> PROCEDURE ob_state(tree&,ob&,flag&,value!)
LOCAL adr%
LET adr%=V:fv_obdata$+fv_obdata%(tree&)+ADD(ob&,ob&)
IF value!
WORD{adr%}=WORD(BSET(WORD{adr%},SUB(flag&,8)))
ELSE
WORD{adr%}=WORD(BCLR(WORD{adr%},SUB(flag&,8)))
ENDIF
RETURN
> FUNCTION menu_register(ap_id&,str_adr%)
$F%
GCONTRL(0)=35
GCONTRL(1)=1
GCONTRL(2)=1
GCONTRL(3)=1
GCONTRL(4)=1
GINTIN(0)=ap_id&
ADDRIN(0)=str_adr%
GEMSYS
RETURN GINTOUT(0)
ENDFUNC
> FUNCTION malloc_system_memory
$F%
LOCAL window_m%,prgdef_m%
window_m%=MUL(ADD(max_number_windows&,1),160)
prgdef_m%=MUL(num_prgdef_objects&,8)
system_pool%=MALLOC(window_m%+prgdef_m%+256)
IF system_pool%<>0
prgdef_adress%=system_pool%+window_m%
st_guide%=prgdef_adress%+prgdef_m%
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ENDFUNC
> PROCEDURE my_form_do(mx&,my&,mc&,index&)
LOCAL object&
@win_place_tree(window_array&(index&,0))
object&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
@my_form_do2(mc&,index&,object&,-1)
RETURN
> PROCEDURE pointback_object(tree&,VAR object&)
DO WHILE object&>0
object&=PRED(object&)
LOOP UNTIL NOT @ob_flags(tree&,object&,13)
RETURN
> PROCEDURE keycalc(key&,VAR ascii|,scan|)
$F%
scan|=BYTE(SHR(key&,8))
IF BYTE(key&)=0 AND scan|>=120 AND scan|<=129
ascii|=BYTE{LONG{XBIOS(16,L:-1,L:-1,L:-1)}+SUB(scan|,118)}
ELSE
ascii|=BYTE{LONG{XBIOS(16,L:-1,L:-1,L:-1)}+scan|}
ENDIF
RETURN
> FUNCTION keyascii(key&)
$F%
LOCAL asc|,scn|
@keycalc(key&,asc|,scn|)
RETURN asc|
ENDFUNC
> PROCEDURE handle_keypress(k_state&,key&)
LOCAL scan|,handle&,d&,index&,ascii|,shc!
~WIND_GET(0,10,handle&,d&,d&,d&)
index&=@win_get_index(handle&)
@keycalc(key&,ascii|,scan|)
IF index&<>-1
IF window_array&(index&,21)=-1 AND window_array&(index&,23)=0
IF window_array&(index&,4)>0
IF scan|=98
IF @help_object(window_array&(index&,4),window_tree%(index&,0))
@user_rsc_context_help(window_array&(index&,4))
shc!=TRUE
ENDIF
ENDIF
IF BTST(window_array&(index&,2),5) AND window_array&(index&,1)=0
shc!=@menu_shortcuts(window_tree%(index&,0),window_array&(index&,4),k_state&,ascii|,scan|)
ELSE
IF scan|=97 AND k_state&=0
shc!=@closer_object(window_array&(index&,0))
ENDIF
IF (BTST(k_state&,3) OR ascii|=13) AND shc!=FALSE
shc!=@dialog_shortcuts(index&,AND(k_state&,&X11),ascii|)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF NOT shc!
IF NOT no_w_topping!
shc!=@menu_shortcuts(menubar_adress%,current_menubar&,k_state&,ascii|,scan|)
ENDIF
ENDIF
IF NOT shc!
IF index&<>-1
IF window_array&(index&,21)=-1 AND window_array&(index&,23)=0
IF window_array&(index&,1)>0
IF scan|=82 AND window_array&(index&,2)>0
~@win_open_dialog(4,fvt_asci&,-1)
ENDIF
IF (scan|=28 OR scan|=114) OR window_array&(index&,2)>0
@fgtext_input(k_state&,key&,@win_get_index(handle&))
ENDIF
ELSE
@user_keyb(handle&,window_array&(index&,8),index&,k_state&,key&)
ENDIF
ENDIF
ELSE
@user_keyb(handle&,0,index&,k_state&,key&)
ENDIF
ENDIF
RETURN
> PROCEDURE rsc_window_message(ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
LOCAL d&,dy&,index&
SELECT m0&
CASE 20     !redraw
@rsc_redraw(m3&,m4&,m5&,m6&,m7&)
CASE 22     !closed
index&=@win_get_index(m3&)
IF window_array&(index&,1)=5
exit_program!=TRUE
ENDIF
IF @closer_object(m3&)=FALSE
@win_close(m3&)
ENDIF
CASE 28     !moved
m4&=@win_snap(m4&)
IF m3&=progress_handle&
~WIND_GET(0,4,d&,dy&,d&,d&)
m5&=MAX(MUL(DIV(ADD(m5&,2),4),4),dy&)
IF NOT snap_windows!
m4&=MUL(DIV(ADD(m4&,2),4),4)
ENDIF
ENDIF
~WIND_SET(m3&,5,m4&,m5&,m6&,m7&)
@win_place_tree(m3&)
CASE 33     !bottomed
index&=@win_get_index(m3&)
IF window_array&(index&,1)<>1 AND window_array&(index&,1)<>4
~WIND_SET(m3&,25,0,0,0,0)
ENDIF
ENDSELECT
RETURN
> PROCEDURE setup_all_trees
LOCAL a&
FOR a&=0 TO last_tree&
@rsc_setup_tree(a&)
NEXT a&
RETURN
> PROCEDURE rsc_redraw(handle&,x&,y&,w&,h&)
LOCAL rx&,ry&,rw&,rh&,top_handle&,d&,index&
LOCAL dx&,dy&,dw&,dh&
@aes_screen_lock_only_screen
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
~WIND_GET(0,10,top_handle&,d&,d&,d&)
~WIND_GET(handle&,11,rx&,ry&,rw&,rh&)
index&=@win_get_index(handle&)
@win_place_tree(handle&)
IF top_handle&=handle&
IF window_array&(index&,2)<>0
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
ENDIF
ENDIF
WHILE rw& OR rh&
IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
IF window_array&(index&,21)<>-1
INT{INT{faceval_sys%}+faceval_sys%-2}=1
~OBJC_DRAW(window_tree%(index&,2),0,7,rx&,ry&,rw&,rh&)
INT{INT{faceval_sys%}+faceval_sys%-2}=0
ELSE
INT{INT{faceval_sys%}+faceval_sys%-2}=1
~OBJC_DRAW(window_tree%(index&,0),0,7,rx&,ry&,rw&,rh&)
INT{INT{faceval_sys%}+faceval_sys%-2}=0
CLIP rx&,ry&,rw&,rh& OFFSET 0,0
@user_rsc_draw_extra(window_array&(index&,8),index&,window_array&(index&,4),window_tree%(index&,0),rx&,ry&,rw&,rh&)
CLIP OFF
ENDIF
ENDIF
ENDIF
~WIND_GET(handle&,12,rx&,ry&,rw&,rh&)
WEND
IF window_array&(index&,21)=-1
IF top_handle&=handle&
IF window_array&(index&,2)<>0
@cursor_on(index&)
ENDIF
ENDIF
ENDIF
@aes_screen_unlock_only_screen
RETURN
> PROCEDURE main_loop
LOCAL event&,mx&,my&,mb&,k_state&,key&,mc&,evnt_flags&
LOCAL time&
WHILE NOT (exit_program! OR forced_exit!)
evnt_flags&=&X10011
LET time&=-1
event&=EVNT_MULTI(evnt_flags&,256+2,3,0,fvrc_evnt&(1),fvrc_evnt&(2),fvrc_evnt&(3),fvrc_evnt&(4),fvrc_evnt&(5),fvrc_evnt&(6),fvrc_evnt&(7),fvrc_evnt&(8),fvrc_evnt&(9),fvrc_evnt&(10),0,time&,mx&,my&,mb&,k_state&,key&,mc&)
IF BTST(event&,0)
@handle_keypress(k_state&,key&)
ENDIF
IF BTST(event&,1)
@main_loop_mouse(mx&,my&,mb&,k_state&,key&,mc&)
ENDIF
IF BTST(event&,4)
@main_message(mx&,my&,mc&,k_state&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
ENDIF
IF exit_program!
exit_program!=@user_quit_ok
ENDIF
WEND
RETURN
> PROCEDURE main_loop_mouse(mx&,my&,mb&,k_state&,key&,mc&)
LOCAL index&,handle&,d&,object&,winx&,winy&
index&=@win_get_index(WIND_FIND(mx&,my&))
IF index&<>-1
~WIND_GET(0,10,handle&,d&,d&,d&)
IF handle&=window_array&(index&,0)
SELECT window_array&(index&,1)
CASE 0
IF BTST(window_array&(index&,2),0)
object&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
@win_place_tree(handle&)
ENDIF
IF BTST(window_array&(index&,2),1) OR BTST(window_array&(index&,2),2)
IF mb&=1 AND object&>0
@my_form_do(mx&,my&,mc&,index&)
ELSE IF object&=0
@user_mouse(handle&,window_array&(index&,8),index&,mx&,my&,mc&,mb&,k_state&)
ENDIF
ELSE
@user_mouse(handle&,window_array&(index&,8),index&,mx&,my&,mc&,mb&,k_state&)
ENDIF
CASE 1,2,3
IF mb&=1 AND mc&
@my_form_do(mx&,my&,mc&,index&)
ENDIF
CASE 4
IF mb&=1
@win_ascii_click(handle&,mx&,my&)
ENDIF
ENDSELECT
ELSE
IF window_array&(index&,1)=0
@user_mouse(handle&,window_array&(index&,8),index&,mx&,my&,mc&,mb&,k_state&)
ELSE
@my_form_do(mx&,my&,mc&,index&)
ENDIF
ENDIF
ENDIF
RETURN
> PROCEDURE main_message(mx&,my&,mc&,ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
LOCAL ob&,flags&,state&,type&,user!,handle&,d&
LOCAL pos&,index&
LOCAL x&,y&,w&,h&
SELECT m0&
CASE 10
@menu_selected(m3&,m4&)
CASE 21     !topped
IF no_w_topping!
@fix_editcursor(window_array&(top_modal&,0))
~WIND_SET(window_array&(top_modal&,0),10,0,0,0,0)
ELSE
LET index&=@win_get_index(m3&)
IF index&=>0
IF window_array&(index&,1)=3
ob&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
IF ob&=-1
@fix_editcursor(m3&)
~WIND_SET(m3&,10,0,0,0,0)
ELSE
~WIND_GET(0,10,handle&,d&,d&,d&)
IF @win_get_index(handle&)<>-1
type&=BYTE(OB_TYPE(window_tree%(@win_get_index(m3&),0),ob&))
flags&=OB_FLAGS(window_tree%(@win_get_index(m3&),0),ob&)
IF (BTST(flags&,0) OR BTST(flags&,2) OR BTST(flags&,4) OR BTST(flags&,6)) AND NOT (@ob_state(window_array&(@win_get_index(m3&),4),ob&,12) AND BTST(flags&,6) AND type&=30)
@my_form_do(mx&,my&,mc&,@win_get_index(m3&))
ELSE
@fix_editcursor(m3&)
~WIND_SET(m3&,10,0,0,0,0)
ENDIF
ELSE
@fix_editcursor(m3&)
~WIND_SET(m3&,10,0,0,0,0)
ENDIF
ENDIF
ELSE IF window_array&(@win_get_index(m3&),1)=0 AND window_array&(@win_get_index(m3&),24)=2
IF BTST(window_array&(@win_get_index(m3&),2),0)
ob&=OBJC_FIND(window_tree%(@win_get_index(m3&),0),0,7,mx&,my&)
ELSE
ob&=-1
ENDIF
IF ob&=-1
@win_get_workarea(@win_get_index(m3&),x&,y&,w&,h&)
IF RC_INTERSECT(mx&,my&,1,1,x&,y&,w&,h&)
@user_mouse(m3&,window_array&(@win_get_index(m3&),8),@win_get_index(m3&),mx&,my&,mc&,1,ks&)
ELSE
~WIND_SET(m3&,10,0,0,0,0)
ENDIF
ELSE
IF @win_get_index(m3&)<>-1
type&=BYTE(OB_TYPE(window_tree%(@win_get_index(m3&),0),ob&))
flags&=OB_FLAGS(window_tree%(@win_get_index(m3&),0),ob&)
IF (BTST(flags&,0) OR BTST(flags&,2) OR BTST(flags&,4) OR BTST(flags&,6)) AND NOT (@ob_state(window_array&(@win_get_index(m3&),4),ob&,12) AND BTST(flags&,6) AND type&=30)
@my_form_do(mx&,my&,mc&,@win_get_index(m3&))
ELSE
IF BTST(window_array&(@win_get_index(m3&),2),5)
@win_get_workarea(@win_get_index(m3&),x&,y&,w&,h&)
IF RC_INTERSECT(mx&,my&,1,1,x&,y&,w&,h&)
@user_mouse(m3&,window_array&(@win_get_index(m3&),8),@win_get_index(m3&),mx&,my&,mc&,1,ks&)
ELSE
~WIND_SET(m3&,10,0,0,0,0)
ENDIF
ELSE
@win_get_workarea(@win_get_index(m3&),x&,y&,w&,h&)
IF RC_INTERSECT(mx&,my&,1,1,x&,y&,w&,h&)
@user_mouse(m3&,window_array&(@win_get_index(m3&),8),@win_get_index(m3&),mx&,my&,mc&,1,ks&)
ELSE
~WIND_SET(m3&,10,0,0,0,0)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ELSE
@fix_editcursor(m3&)
~WIND_SET(m3&,10,0,0,0,0)
ENDIF
ENDIF
ENDIF
CASE 30,31
LET index&=@win_get_index(m3&)
IF index&=>0
@fix_editcursor(m3&)
ENDIF
CASE 22360 !wm_shaded
LET index&=@win_get_index(m3&)
IF index&=>0
window_array&(index&,23)=-1
ENDIF
CASE 22361 !wm_unshaded
LET index&=@win_get_index(m3&)
IF index&=>0
window_array&(index&,23)=0
ENDIF
CASE 50
forced_exit!=TRUE
CASE 20,33,22 TO 28
LET index&=@win_get_index(m3&)
IF index&=>0
IF window_array&(index&,1)>0
@rsc_window_message(ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
ELSE
@window_message(ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
ENDIF
ENDIF
CASE 53
@handle_keypress(0,m3&)
CASE &H4710
@handle_keypress(m3&,m4&)
CASE &H4709
@main_loop_mouse(m3&,m4&,m5&,m6&,0,m7&)
DEFAULT
@user_gem_messages(mx&,my&,ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
user!=TRUE
ENDSELECT
IF gem_through&>0 AND user!=FALSE
@user_gem_messages(mx&,my&,ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
ENDIF
RETURN
> PROCEDURE my_form_do2(mc&,index&,object&,regob&)
LOCAL root&,a&,ob_spec%,sub&
LOCAL mx&,my&,d&,cur_edit&,changed!
LOCAL tree%,done!
LET changed!=TRUE
CLR done!
IF object&>0
IF window_array&(index&,0)>0
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),3)
IF NOT @ob_state(window_array&(index&,4),object&,12)
IF mc&=2 AND BTST(OB_FLAGS(window_tree%(index&,0),object&),0)
@aes_screen_lock
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
LET cur_edit&=window_array&(index&,2)
LET window_array&(index&,2)=-1
OB_STATE(window_tree%(index&,0),object&)=BSET(OB_STATE(window_tree%(index&,0),object&),0)
@rsc_ob_draw(index&,object&)
~EVNT_TIMER(100)
OB_STATE(window_tree%(index&,0),object&)=BCLR(OB_STATE(window_tree%(index&,0),object&),0)
@rsc_ob_draw(index&,object&)
LET window_array&(index&,2)=cur_edit&
@cursor_on(index&)
@aes_screen_unlock
@user_rsc_interact(index&,window_array&(index&,4),object&,2,-1)
LET done!=TRUE
ELSE
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
window_array&(index&,2)=object&
~GRAF_MKSTATE(mx&,my&,d&,d&)
window_array&(index&,3)=@click_set_cursor(index&,mx&,my&,window_array&(index&,3))
ENDIF
ENDIF
ENDIF
ENDIF
IF NOT done!
ob_spec%=OB_SPEC(window_tree%(index&,0),object&)
IF NOT BTST(OB_FLAGS(window_tree%(index&,0),object&),7)
IF NOT BTST(OB_STATE(window_tree%(index&,0),object&),3)
IF @ob_flags(window_array&(index&,4),object&,13) AND BTST(OB_FLAGS(window_tree%(index&,0),object&),6)
@pointback_object(window_array&(index&,4),object&)
ENDIF
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6) AND NOT (BTST(OB_FLAGS(window_tree%(index&,0),object&),4) OR BTST(OB_FLAGS(window_tree%(index&,0),object&),0))
IF @pointforward_object(index&,object&)
ADD object&,1
IF @pointforward_object(index&,object&)
ADD object&,1
ENDIF
ENDIF
IF sub&=0
sub&=@popup_sub_formdo(index&,object&)
ENDIF
IF changed!
@rsc_read_tree(window_array&(index&,4),object&)
@user_rsc_interact(index&,window_array&(index&,4),object&,mc&,sub&)
ENDIF
ELSE
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),0)
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),2)      !exit
~@my_form_button(index&,object&,mc&)
IF BTST(OB_STATE(window_tree%(index&,0),object&),0)
LET tree%=window_tree%(index&,0)
IF @ob_flags(window_array&(index&,4),object&,15)
@user_rsc_context_help(window_array&(index&,4))
ELSE
@user_rsc_interact(index&,window_array&(index&,4),object&,mc&,0)
ENDIF
~EVNT_TIMER(50)
OB_STATE(tree%,object&)=BCLR(OB_STATE(tree%,object&),0)
IF window_tree%(index&,0)=tree% AND window_array&(index&,0)<>0
@rsc_ob_draw(index&,object&)
ENDIF
ENDIF
ELSE IF BTST(OB_FLAGS(window_tree%(index&,0),object&),4) !radiobutton
IF BTST(OB_STATE(window_tree%(index&,0),object&),0)=FALSE
root&=object&
DO
root&=OB_NEXT(window_tree%(index&,0),root&)
LOOP UNTIL root&<object&
a&=OB_HEAD(window_tree%(index&,0),root&)
DO
IF BTST(OB_FLAGS(window_tree%(index&,0),a&),4) AND BTST(OB_STATE(window_tree%(index&,0),a&),0)
OB_STATE(window_tree%(index&,0),a&)=BCLR(OB_STATE(window_tree%(index&,0),a&),0)
@rsc_ob_draw(index&,a&)
ENDIF
a&=OB_NEXT(window_tree%(index&,0),a&)
LOOP UNTIL a&=root&
OB_STATE(window_tree%(index&,0),object&)=BSET(OB_STATE(window_tree%(index&,0),object&),0)
@rsc_ob_draw(index&,object&)
ENDIF
@rsc_read_tree(window_array&(index&,4),object&)
@mouse_wait_realtime
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6)
@user_rsc_interact(index&,window_array&(index&,4),object&,mc&,0)
ENDIF
ELSE                                                   !selectable
IF @my_form_button(index&,object&,mc&)
@rsc_read_tree(window_array&(index&,4),object&)
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),6)
@user_rsc_interact(index&,window_array&(index&,4),object&,mc&,0)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
> PROCEDURE keypress(key&)                                                !call
@aes_internal_message(53,key&,0,0,0,0)
RETURN
> FUNCTION my_form_button(index&,object&,mc&)
$F%
LOCAL to_select!,changed!
LOCAL selected_state&,unselected_state&
LOCAL current_state&,new_state&
LOCAL mx&,my&,d&
LOCAL current_ob&
LOCAL evnt_flags&,time&
@aes_screen_lock
LET to_select!=NOT BTST(OB_STATE(window_tree%(index&,0),object&),0)
LET selected_state&=BSET(OB_STATE(window_tree%(index&,0),object&),0)
LET unselected_state&=BCLR(OB_STATE(window_tree%(index&,0),object&),0)
REPEAT
IF mc&=0
LET changed!=TRUE
ELSE
~GRAF_MKSTATE(mx&,my&,mc&,d&)
LET current_ob&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
IF current_ob&=>0
IF @ob_flags(window_array&(index&,4),current_ob&,13) AND BTST(OB_FLAGS(window_tree%(index&,0),current_ob&),6)
@pointback_object(window_array&(index&,4),current_ob&)
ENDIF
ENDIF
LET changed!=(current_ob&=object&)
LET evnt_flags&=&X100000
LET time&=20
event&=EVNT_MULTI(evnt_flags&,256+2,3,0,0,0,0,0,0,0,0,0,0,0,0,time&,d&,d&,d&,d&,d&,d&)
ENDIF
IF to_select! EQV changed!
LET new_state&=selected_state&
ELSE
LET new_state&=unselected_state&
ENDIF
LET current_state&=OB_STATE(window_tree%(index&,0),object&)
IF current_state&<>new_state&
OB_STATE(window_tree%(index&,0),object&)=new_state&
@rsc_ob_draw(index&,object&)
ENDIF
UNTIL mc&=0
@mouse_wait_realtime
@aes_screen_unlock
RETURN changed!
ENDFUNC
> PROCEDURE aes_screen_lock                                               !call
@aes_screen_lock_only_screen
@aes_screen_lock_only_mouse
RETURN
> PROCEDURE aes_screen_unlock                                             !call
@aes_screen_unlock_only_mouse
@aes_screen_unlock_only_screen
RETURN
> PROCEDURE aes_screen_lock_only_screen                                   !call
IF fv_aes_lock_num_os&=0
~WIND_UPDATE(1)
ENDIF
INC fv_aes_lock_num_os&
RETURN
> PROCEDURE aes_screen_unlock_only_screen                                 !call
DEC fv_aes_lock_num_os&
IF fv_aes_lock_num_os&=0
~WIND_UPDATE(0)
ENDIF
RETURN
> PROCEDURE aes_screen_lock_only_mouse                                    !call
IF fv_aes_lock_num_om&=0
~WIND_UPDATE(3)
ENDIF
INC fv_aes_lock_num_om&
RETURN
> PROCEDURE aes_screen_unlock_only_mouse                                  !call
DEC fv_aes_lock_num_om&
IF fv_aes_lock_num_om&=0
~WIND_UPDATE(2)
ENDIF
RETURN
> PROCEDURE aes_send_message(id&,m0&,m3&,m4&,m5&,m6&,m7&)                 !call
LOCAL message%
INLINE message%,16
WORD{message%}=m0&
WORD{message%+2}=ap_id&
WORD{message%+4}=0
WORD{message%+6}=m3&
WORD{message%+8}=m4&
WORD{message%+10}=m5&
WORD{message%+12}=m6&
WORD{message%+14}=m7&
~APPL_WRITE(id&,16,message%)
RETURN
> FUNCTION appl_xgetinfo(gtype&,VAR gout1&,gout2&,gout3&,gout4&)          !call
$F%
LOCAL d&,ret%
IF (INT{{ADD(GB,4)}}=&H399 AND magic_version&>=&H200) OR (INT{{ADD(GB,4)}}>=&H400) OR (APPL_FIND("?AGI")>=0) OR winx_version&>=&H210
GCONTRL(0)=130
GCONTRL(1)=1
GCONTRL(2)=5
GCONTRL(3)=0
GCONTRL(4)=0
GINTIN(0)=gtype&
GEMSYS
gout1&=GINTOUT(1)
gout2&=GINTOUT(2)
gout3&=GINTOUT(3)
gout4&=GINTOUT(4)
LET ret%=GINTOUT(0)
IF ret%<>0
RETURN ret%
ENDIF
ENDIF
CLR gout1&
CLR gout2&
CLR gout3&
CLR gout4&
RETURN 0
ENDFUNC
> FUNCTION aes_send_message_by_name(app_name$,m0&,m3&,m4&,m5&,m6&,m7&)    !call
$F%
LOCAL id&
LET app_name$=app_name$+SPACE$(MAX(0,SUB(8,LEN(app_name$))))
LET id&=APPL_FIND(app_name$)
IF id&<>-1
@aes_send_message(id&,m0&,m3&,m4&,m5&,m6&,m7&)
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ENDFUNC
> PROCEDURE do_all_redraws                                                !call
DO
EXIT IF NOT BTST(EVNT_MULTI(&X110000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),4)
IF MENU(1)=20 OR MENU(1)=28
@main_message(0,0,0,0,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
ELSE
LET msg$=SPACE$(16)
BMOVE MENU(-2),V:msg$,16
LET all_msg$=all_msg$+msg$
ENDIF
LOOP
WHILE LEN(all_msg$)>0
~APPL_WRITE(ap_id&,16,V:all_msg$)
LET all_msg$=MID$(all_msg$,17)
WEND
RETURN
> PROCEDURE start_up
LOCAL x&,y&,w&,h&
LOCAL gout1&,d&
LOCAL magx_cookie%
LOCAL fh&,file$,lof%,ret%
LET mxmask%=@mxmask
@user_inline_load
INT{INT{faceval_sys%}+faceval_sys%-2}=0
ap_id&=APPL_INIT()
IF ap_id&=-1
~APPL_EXIT()
END
ENDIF
magic_version&=0
IF INT{ADD({ADD(GB,4)},2)}<>1 AND @get_cookie("MagX",magx_cookie%)
magic_version&=INT{ADD({ADD(magx_cookie%,8)},48)}
ENDIF
winx_version&=0
IF WIND_GET(0,1,d&,d&,d&,d&)=0
IF WIND_GET(0,22360,winx_version&,d&,d&,d&)=22360
winx_version&=OR(winx_version&,&HFFF)
ENDIF
ENDIF
@program_init
acc!=({ADD(BASEPAGE,36)}=0)
return_value&=1
@init
DIM window_array%(max_number_windows&,3)
~@menu_register(-1,faceval_sys%+2892)         ! set name for appl_find
IF acc!
menu_id&=@menu_register(ap_id&,faceval_sys%+2854)
DO
~EVNT_MESAG(0)
IF MENU(1)=40
~FORM_ALERT(1,not_accessory$)
ENDIF
LOOP
ENDIF
program_path$=CHR$(65+GEMDOS(25))+":"+DIR$(GEMDOS(25)+1)+"\"
multitasking!=WORD{{GB+4}+2}<>1
IF @systemcheck
IF @get_rsc<>0
IF @malloc_system_memory
flydials_handle&=@v_opnvwk
IF flydials_handle&<>0
return_value&=0
~@vsf_color(flydials_handle&,1)
V~H=-1
@install_prg_def_main
@user_rsc_var_init
IF multitasking! OR acc!
LET menu_id&=@menu_register(ap_id&,faceval_sys%+2854)
ENDIF
~@appl_xgetinfo(12,gout1&,d&,d&,d&)
IF BTST(gout1&,3)
~SHEL_WRITE(9,1,0,"","")   ! support AP_TERM
ENDIF
IF current_menubar&=>0
menubar_adress%=@xrsrc_gaddr(0,current_menubar&)
ELSE
CLR menubar_adress%
ENDIF
@setup_all_trees
~GRAF_MOUSE(0,0)
@aes_screen_lock_only_screen
IF menubar_adress%<>0
@menu_snap(current_menubar&)
~MENU_BAR(menubar_adress%,1)
ENDIF
@aes_screen_unlock_only_screen
IF NOT compiled!
~WIND_GET(0,4,x&,y&,w&,h&)
~FORM_DIAL(3,0,0,0,0,x&,y&,w&,h&)
ENDIF
@user_on_open
@main_loop
@win_close_all
@aes_screen_lock_only_screen
~MENU_BAR(0,0)
@aes_screen_unlock_only_screen
@user_on_exit
IF NOT acc!
~WIND_SET(0,14,0,0,0,0)
ENDIF
@v_clsvwk(flydials_handle&)
V~H=-1
ELSE
~@alert_standard(1,3,"")
ENDIF
~MFREE(system_pool%)
ELSE
~@alert_standard(1,1,"")
ENDIF
@cleanup_after_rsc
ELSE
~FORM_ALERT(1,no_rsc_found$)
ENDIF
ENDIF
~APPL_EXIT()
IF compiled!
QUIT return_value&
ELSE
RESERVE
EDIT
ENDIF
RETURN
> FUNCTION mxalloc_global(amount%)                                        !call
$F%
IF mxmask%<>0
RETURN GEMDOS(68,L:amount%,&X100011 AND mxmask%)
ELSE
RETURN MALLOC(amount%)
ENDIF
ENDFUNC
> FUNCTION mxmask
IF GEMDOS(68,L:-1,0)=-32
RETURN 0
ELSE IF GEMDOS(290,-1)=-32
RETURN 3
ELSE
RETURN -1
ENDIF
ENDFUNC
> PROCEDURE program_init
LET program_va_init_!=FALSE
LET program_va_bufadr_%=@mxalloc_global(256)
IF program_va_bufadr_%<>0
LET program_va_bufadr2_%=@mxalloc_global(256)
IF program_va_bufadr2_%<>0
LET program_va_init_!=TRUE
LET program_va_bufsize_%=256
ELSE
~MFREE(program_va_bufadr_%)
ENDIF
ENDIF
LET program_avserver_$=@program_getenv$("AVSERVER")
RETURN
> FUNCTION program_va_start(app_name$,cmd$)
$F%
LOCAL m3&,m4&,return!,cmdsize%,newbuf%
CLR return!
IF program_va_init_!
LET cmd$=@program_cml_build$(cmd$)
LET cmdsize%=SUCC(LEN(cmd$))
IF cmdsize%>program_va_bufsize_%
LET newbuf%=@mxalloc_global(newsize%)
IF newbuf%<>0
~MFREE(program_va_bufadr_%)
LET program_va_bufadr_%=newbuf%
LET program_va_bufsize_%=cmdsize%
ENDIF
ENDIF
IF cmdsize%<=program_va_bufsize_%
LET m3&=WORD(SHR(program_va_bufadr_%,16))
LET m4&=WORD(program_va_bufadr_%)
CHAR{program_va_bufadr_%}=cmd$
LET return!=@aes_send_message_by_name(app_name$,&H4711,m3&,m4&,0,0,0)
ENDIF
ENDIF
RETURN return!
ENDFUNC
> FUNCTION program_av_startprog(app_fname$,cmd$,userhandle&)
$F%
LOCAL m3&,m4&,m5&,m6&,m7&
LOCAL return!,cmdsize%,newbuf%
IF multitasking! OR acc!
IF program_va_init_!
IF program_avserver_$<>""
IF LEN(app_fname$)<256
LET cmd$=@program_cml_build$(cmd$)
LET cmdsize%=SUCC(LEN(cmd$))
IF cmdsize%>program_va_bufsize_%
LET newbuf%=@mxalloc_global(newsize%)
IF newbuf%<>0
~MFREE(program_va_bufadr_%)
LET program_va_bufadr_%=newbuf%
LET program_va_bufsize_%=cmdsize%
ENDIF
ENDIF
IF cmdsize%<=program_va_bufsize_%
LET m3&=WORD(SHR(program_va_bufadr2_%,16))
LET m4&=WORD(program_va_bufadr2_%)
LET m5&=WORD(SHR(program_va_bufadr_%,16))
LET m6&=WORD(program_va_bufadr_%)
LET m7&=userhandle&
CHAR{program_va_bufadr2_%}=app_fname$
CHAR{program_va_bufadr_%}=cmd$
LET return!=@aes_send_message_by_name(program_avserver_$,&H4722,m3&,m4&,m5&,m6&,m7&)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN return!
ENDFUNC
> FUNCTION program_getenv$(envname$)                                      !call
LOCAL adr%,value$,return$
IF RIGHT$(envname$)<>"="
LET envname$=envname$+"="
ENDIF
LET adr%={ADD(BASEPAGE,44)}
DO
LET value$=CHAR{adr%}
EXIT IF LEFT$(value$,5)="ARGV=" OR value$="ARGV" OR value$=""
ADD adr%,SUCC(LEN(value$))
IF LEFT$(value$,LEN(envname$))=envname$
LET return$=MID$(value$,SUCC(LEN(envname$)))
EXIT IF TRUE
ENDIF
LOOP
IF return$=""
~SHEL_ENVRN(adr%,envname$)
IF adr%<>0
LET return$=CHAR{adr%}
ENDIF
ENDIF
RETURN return$
ENDFUNC
> FUNCTION program_start(app_name$,env_name$,app_fname$,single_cmd$,multi_cmd$,env$,def_path$,userhandle&)     !call
LOCAL app_fname_env$
LOCAL started!,ret%
CLR started!
LET ret%=-1
IF userhandle&<>-1
IF env$="" AND def_path$=""
IF app_name$<>""
LET started!=@program_va_start(app_name$,multi_cmd$)
ENDIF
IF NOT started!
IF app_fname$<>""
LET started!=@program_av_startprog(app_fname$,multi_cmd$,userhandle&)
ENDIF
IF NOT started!
IF env_name$<>""
LET app_fname_env$=@program_getenv$(env_name$)
IF app_fname_env$<>""
LET app_fname$=app_fname_env$
LET started!=@program_av_startprog(app_fname$,multi_cmd$,userhandle&)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN 0
ENDFUNC
> FUNCTION program_cml_build$(cml$)
LOCAL pos&,par$,newcml$
LET pos&=INSTR(cml$,CHR$(0))
IF pos&=0
LET newcml$=cml$
ELSE
CLR newcml$
WHILE pos&>0
LET par$=LEFT$(cml$,PRED(pos&))
LET cml$=MID$(cml$,SUCC(pos&))
IF LEN(par$)=0
LET par$="' '"
ELSE IF INSTR(par$," ")>0
LET pos&=LEN(par$)
WHILE pos&>0
IF MID$(par$,pos&,1)="'"
LET par$=LEFT$(par$,pos&)+MID$(par$,pos&)
ENDIF
DEC pos&
WEND
LET par$="'"+par$+"'"
ENDIF
IF par$<>""
IF LEN(newcml$)>0
LET newcml$=newcml$+" "+par$
ELSE
LET newcml$=par$
ENDIF
ENDIF
LET pos&=INSTR(cml$,CHR$(0))
WEND
ENDIF
RETURN newcml$
ENDFUNC
> FUNCTION program_cml_unbuild$(cml$)
LOCAL newcml$,pos&,len&,space!,quote!,char$,par!
IF INSTR(cml$,CHR$(0))=0
LET pos&=1
LET len&=LEN(cml$)
LET space!=TRUE
LET par!=FALSE
WHILE pos&<=len&
LET char$=MID$(cml$,pos&,1)
SELECT char$
CASE " "
IF quote!
LET newcml$=newcml$+" "
ELSE
IF NOT space!
LET newcml$=newcml$+CHR$(0)
ENDIF
LET space!=TRUE
ENDIF
CASE "'"
IF quote!
IF MID$(cml$,pos&,2)="''"
LET newcml$=newcml$+"'"
INC pos&
ELSE
LET quote!=FALSE
LET space!=TRUE
LET newcml$=newcml$+CHR$(0)
ENDIF
ELSE
IF space!
IF MID$(cml$,pos&,3)="' '"
LET newcml$=newcml$+CHR$(0)
ADD pos&,2
ELSE
LET quote!=TRUE
CLR space!
ENDIF
ELSE
LET newcml$=newcml$+"'"
ENDIF
ENDIF
DEFAULT
LET newcml$=newcml$+char$
LET space!=FALSE
ENDSELECT
INC pos&
WEND
IF NOT space!
LET newcml$=newcml$+CHR$(0)
ENDIF
RETURN newcml$
ELSE
RETURN cml$
ENDIF
ENDFUNC
> PROCEDURE system_error      !This proc. can be deleted before compiling  !-CMP
LOCAL d&
ALERT 1,"Error: "+STR$(ERR)+" |"+MID$(ERR$(ERR),3,INSTR(ERR$(ERR),"Return")-3),1,"  OK  ",d&
@system_restore
RETURN
> PROCEDURE system_restore    !This proc. can be deleted before compiling  !-CMP
IF fv_aes_lock_num_om&>0
~WIND_UPDATE(2)
ENDIF
IF fv_aes_lock_num_os&>0
~WIND_UPDATE(0)
ENDIF
IF fv_malloced%>0
~MFREE(fv_malloced%)
ENDIF
@win_close_all
~WIND_UPDATE(1)
~MENU_BAR(0,0)
~WIND_UPDATE(0)
@user_on_exit
~WIND_SET(0,14,0,0,0,0)
@v_clsvwk(flydials_handle&)
~MFREE(system_pool%)
@cleanup_after_rsc
IF INT{{ADD(GB,4)}}>=&H320  !AES>3.20
GCONTRL(0)=109            !wind_new()
GCONTRL(1)=0
GCONTRL(2)=0
GCONTRL(3)=0
GCONTRL(4)=0
GEMSYS
ENDIF
CLOSE
~APPL_EXIT()
RESERVE
EDIT
RETURN
> PROCEDURE disable_menus(disable!)
LOCAL d&
IF menubar_adress%<>0
IF disable!<>menu_disabled!
IF NOT acc!
IF current_menutitle&<>-1
~MENU_TNORMAL(menubar_adress%,current_menutitle&,1)
current_menutitle&=-1
ENDIF
d&=3
DO
INC d&
IF OB_TYPE(menubar_adress%,d&)=32
IF disable!
OB_STATE(menubar_adress%,d&)=BSET(OB_STATE(menubar_adress%,d&),3)
ELSE
OB_STATE(menubar_adress%,d&)=BCLR(OB_STATE(menubar_adress%,d&),3)
ENDIF
ENDIF
LOOP UNTIL BTST(OB_FLAGS(menubar_adress%,d&),5)
d&=0
DO
IF OB_TYPE(menubar_adress%,d&)=28
IF disable!
OB_STATE(menubar_adress%,d&)=BSET(OB_STATE(menubar_adress%,d&),3)
ELSE
OB_STATE(menubar_adress%,d&)=BCLR(OB_STATE(menubar_adress%,d&),3)
ENDIF
EXIT IF TRUE
ENDIF
INC d&
LOOP UNTIL BTST(OB_FLAGS(menubar_adress%,d&),5)
@aes_screen_lock_only_screen
~MENU_BAR(menubar_adress%,1)
@aes_screen_unlock_only_screen
ENDIF
menu_disabled!=disable!
no_w_topping!=disable!
ENDIF
ENDIF
RETURN
> PROCEDURE menu_snap(tree&)
LOCAL menu%,box&,menu_desktop&
LET menu%=@xrsrc_gaddr(0,tree&)
LET menu_desktop&=OB_TAIL(menu%,0)
LET box&=OB_HEAD(menu%,menu_desktop&)
WHILE box&<>menu_desktop& AND box&>0
OB_X(menu%,box&)=MAX(0,MIN(OB_X(menu%,box&),SUB(OB_W(menu%,menu_desktop&),OB_W(menu%,box&))))
LET box&=OB_NEXT(menu%,box&)
WEND
RETURN
> FUNCTION menu_shortcuts(tree%,tree&,k_state&,ascii|,scan|)
$F%
LOCAL a&,about!,compare$,shortcut$
IF AND(k_state&,&X11)
shortcut$=""
ENDIF
IF BTST(k_state&,2)
shortcut$=shortcut$+"^"
ENDIF
IF BTST(k_state&,3)
shortcut$=shortcut$+""
ENDIF
SELECT scan|
CASE 99 TO 113,74,78
shortcut$=shortcut$+"["+UPPER$(CHR$(ascii|))+"]"
CASE 1
shortcut$=shortcut$+"Esc"
CASE 14
shortcut$=shortcut$+"BS"
CASE 15
shortcut$=shortcut$+"Tab"
CASE 59 TO 68
shortcut$=shortcut$+"F"+STR$(scan|-58)
CASE 84 TO 93
shortcut$=shortcut$+"F"+STR$(scan|-73)
IF LEFT$(shortcut$)=""
shortcut$=RIGHT$(shortcut$,LEN(shortcut$)-1)
ENDIF
CASE 98
shortcut$=shortcut$+"Help"
CASE 82
shortcut$=shortcut$+"Insert"
CASE 71,119
shortcut$=shortcut$+"Home"
CASE 97
shortcut$=shortcut$+"Undo"
CASE 57
shortcut$=shortcut$+"Space"
DEFAULT
IF ascii|>32
IF ascii|=127
shortcut$=shortcut$+"Del"
ELSE
shortcut$=shortcut$+UPPER$(CHR$(ascii|))
ENDIF
ENDIF
ENDSELECT
about!=FALSE
a&=2
DO
INC a&
IF OB_TYPE(tree%,a&)=28
IF BTST(OB_STATE(tree%,a&),3)=0
compare$=TRIM$(CHAR{OB_SPEC(tree%,a&)})
IF RINSTR(compare$," ")
compare$=RIGHT$(compare$,LEN(compare$)-RINSTR(compare$," "))
IF compare$=shortcut$
IF BTST(OB_STATE(tree%,@rsc_find_menutitle(tree&,a&)),3)=0
@user_rsc_interact(-1,tree&,a&,1,0)
RETURN TRUE
ENDIF
ENDIF
ENDIF
ENDIF
IF NOT about!
about!=TRUE
DO
INC a&
LOOP UNTIL OB_TYPE(tree%,a&)=20
ENDIF
ENDIF
LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
RETURN FALSE
ENDFUNC
> PROCEDURE menu_selected(title&,menu_item&)
LOCAL temp&
temp&=current_menubar&
current_menutitle&=title&
@user_rsc_interact(-1,current_menubar&,menu_item&,1,0)
IF temp&=current_menubar& AND current_menutitle&=title&
~MENU_TNORMAL(menubar_adress%,title&,1)
ENDIF
current_menutitle&=-1
RETURN
> FUNCTION win_open(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,user_handle&,x&,y&,w&,h&,icon&) !call
$F%
RETURN @win_open2(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,0,0,user_handle&,x&,y&,w&,h&,icon&,FALSE)
ENDFUNC
> FUNCTION win_open_scrollpos(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,offx%,offy%,user_handle&,x&,y&,w&,h&,icon&) !call
$F%
RETURN @win_open2(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,offx%,offy%,user_handle&,x&,y&,w&,h&,icon&,FALSE)
ENDFUNC
> FUNCTION win_open2(tit$,inf$,kind%,tree&,totw%,toth%,scrlstep_x&,scrlstep_y&,offx%,offy%,user_handle&,x&,y&,w&,h&,icon&,ic!)
$F%
LOCAL handle&,index&,dx&,dy&,dw&,dh&,tree%,d&,xoff&,wchar&,kind&,usrtype&
LOCAL mtype&
index&=@find_free_w_array
IF index&<>-1
IF icon&=-1
kind%=BCLR(kind%,30)
ENDIF
IF BTST(kind%,13)      !program modal
mtype&=0
ELSE IF BTST(kind%,14) !toolbox type
mtype&=2
ELSE                   !non modal
mtype&=1
ENDIF
kind%=BCLR(kind%,13)
kind%=BCLR(kind%,14)
kind&=WORD{V:kind%}
usrtype&=WORD{V:kind%+2}
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
handle&=WIND_CREATE(kind&,dx&,dy&,dw&,dh&)
IF handle&>0
window_array&(index&,0)=handle&
window_array&(index&,1)=0
window_array&(index&,2)=usrtype&
window_array&(index&,3)=kind&
window_array&(index&,4)=tree&
window_array&(index&,5)=icon&
window_array%(index&,0)=totw%
window_array%(index&,1)=toth%
window_array&(index&,8)=user_handle&
window_array&(index&,9)=MAX(1,scrlstep_x&)
window_array&(index&,10)=MAX(1,scrlstep_y&)
window_array&(index&,25)=-1
LET window_array%(index&,2)=offx%
LET window_array%(index&,3)=offy%
window_array&(index&,12)=0
window_array&(index&,13)=0
IF BTST(window_array&(index&,2),0)
tree%=@xrsrc_gaddr(0,tree&)
window_tree%(index&,0)=tree%
IF BTST(window_array&(index&,2),1)        !horisontal toolstrip
window_array&(index&,13)=OB_H(tree%,1)+1
ELSE IF BTST(window_array&(index&,2),2)   !vertical toolstrip
window_array&(index&,12)=OB_W(tree%,1)+1
ELSE IF BTST(window_array&(index&,2),5)   !menu
window_array&(index&,13)=OB_H(tree%,2)
OB_X(tree%,0)=0
OB_Y(tree%,0)=0
~OBJC_OFFSET(tree%,4,xoff&,d&)
~GRAF_HANDLE(wchar&,d&,d&,d&)
window_array&(index&,15)=SUB(xoff&,wchar&)
d&=3
DO
INC d&
LOOP UNTIL OB_TYPE(tree%,d&)=25
window_array&(index&,16)=d&
ENDIF
ENDIF
window_tree%(index&,1)=ADD(system_pool%,MUL(index&,160))
IF icon&<>-1
tree%=@xrsrc_gaddr(0,icon&)
window_tree%(index&,2)=tree%
ELSE
window_tree%(index&,2)=0
ENDIF
@win_set_title(index&,tit$)
@win_set_infoline(index&,inf$)
x&=MIN(MAX(dx&,x&),dx&+dw&-dy&)
y&=MIN(MAX(dy&,y&),dy&+dh&-dy&)
IF w&<0
LET w&=dw&
ENDIF
IF h&<0
LET h&=dh&
ENDIF
@win_align(index&,x&)
~RC_INTERSECT(dx&,dy&,dw&,dh&,x&,y&,w&,h&)
IF BTST(usrtype&,3) OR BTST(usrtype&,7) OR NOT BTST(kind&,5)
@win_limit_size(index&,w&,h&)
ENDIF
~WIND_OPEN(handle&,x&,y&,w&,h&)
@win_set_sliders(index&)
window_array&(index&,24)=mtype&
IF mtype&=0
@disable_menus(-1)
IF top_modal&>-1
window_array&(index&,25)=top_modal&
ENDIF
top_modal&=index&
ENDIF
RETURN handle&
ELSE
~@alert_standard(1,2,"")
RETURN 0
ENDIF
ELSE
~@alert_standard(1,2,"")
RETURN 0
ENDIF
ENDFUNC
> PROCEDURE win_calc_wh(kind%,tree&,icon&,ww&,wh&,VAR w&,h&)              !call
LOCAL kind&,tree%,usrtype&,off_x&,off_y&,x&,y&
IF icon&=-1
LET kind%=BCLR(kind%,30)
ENDIF
LET kind%=BCLR(kind%,13)
LET kind%=BCLR(kind%,14)
LET kind&=WORD{V:kind%}
LET off_x&=0
LET off_y&=0
LET usrtype&=WORD{V:kind%+2}
IF BTST(usrtype&,0)
LET tree%=@xrsrc_gaddr(0,tree&)
IF BTST(usrtype&,1)
LET off_y&=OB_H(tree%,1)+1
ELSE IF BTST(usrtype&,2)
LET off_x&=OB_W(tree%,1)+1
ELSE IF BTST(usrtype&,5)
LET off_y&=OB_H(tree%,2)
ENDIF
ENDIF
~WIND_CALC(0,kind&,0,0,ADD(ww&,off_y&),ADD(wh&,off_y&),x&,y&,w&,h&)
RETURN
> PROCEDURE win_get_workarea(index&,VAR x&,y&,w&,h&)                      !call
~WIND_GET(window_array&(index&,0),4,x&,y&,w&,h&)
ADD y&,window_array&(index&,13)
SUB h&,window_array&(index&,13)
ADD x&,window_array&(index&,12)
SUB w&,window_array&(index&,12)
RETURN
> PROCEDURE win_set_infoline(index&,info$)                                !call
LOCAL adr%
IF window_array&(index&,1)=0
IF BTST(window_array&(index&,3),4)
IF LEN(info$)>78
info$=LEFT$(info$,78)
ENDIF
info$=info$+CHR$(0)
adr%=window_tree%(index&,1)+80
BMOVE V:info$,adr%,LEN(info$)
~WIND_SET(window_array&(index&,0),3,CARD(SWAP(adr%)),CARD(adr%),0,0)
ENDIF
ENDIF
RETURN
> PROCEDURE win_set_sliders(index&)
LOCAL d&,w&,h&
IF window_array&(index&,1)=0
@win_get_workarea(index&,d&,d&,w&,h&)
IF BTST(window_array&(index&,3),11)
@win_set_hslider(index&,w&)
ENDIF
IF BTST(window_array&(index&,3),8)
@win_set_vslider(index&,h&)
ENDIF
ENDIF
RETURN
> PROCEDURE win_set_vslider(index&,hh%)
LOCAL size&
IF BTST(window_array&(index&,3),8)
IF window_array%(index&,1)>hh%
LET size&=ROUND(hh%*1000/window_array%(index&,1))
IF size&<=0
LET size&=-1
ELSE
size&=MIN(size&,1000)
ENDIF
~WIND_SET(window_array&(index&,0),16,size&,0,0,0)
~WIND_SET(window_array&(index&,0),9,ROUND(window_array%(index&,3)*1000/SUB(window_array%(index&,1),hh%)),0,0,0)
ELSE
LET size&=1000
~WIND_SET(window_array&(index&,0),16,size&,0,0,0)
~WIND_SET(window_array&(index&,0),9,0,0,0,0)
ENDIF
ENDIF
RETURN
> PROCEDURE win_set_hslider(index&,ww%)
LOCAL size&
IF BTST(window_array&(index&,3),11)
IF window_array%(index&,0)>ww%
~WIND_SET(window_array&(index&,0),8,ROUND(window_array%(index&,2)*1000/SUB(window_array%(index&,0),ww%)),0,0,0)
LET size&=ROUND(ww%*1000/window_array%(index&,0))
IF size&<=0
LET size&=-1
ELSE
size&=MIN(size&,1000)
ENDIF
ELSE
~WIND_SET(window_array&(index&,0),8,0,0,0,0)
LET size&=1000
ENDIF
~WIND_SET(window_array&(index&,0),15,size&,0,0,0)
ENDIF
RETURN
> PROCEDURE win_limit_size(index&,VAR w&,h&)
LOCAL d&,maxw&,maxh&,dw&,dh&
IF BTST(window_array&(index&,2),3)
~WIND_GET(0,4,d&,d&,dw&,dh&)
~WIND_CALC(0,window_array&(index&,3),0,0,MIN(dw&,window_array%(index&,0)+window_array&(index&,12)),MIN(dh&,window_array%(index&,1)+window_array&(index&,13)),d&,d&,maxw&,maxh&)
w&=MIN(w&,maxw&)
h&=MIN(h&,maxh&)
ENDIF
IF BTST(window_array&(index&,2),7)
IF window_array&(index&,9)>0
~WIND_CALC(1,window_array&(index&,3),0,0,w&,h&,d&,d&,maxw&,maxh&)
maxw&=MUL(DIV(SUB(maxw&,window_array&(index&,12)),window_array&(index&,9)),window_array&(index&,9))
maxh&=MUL(DIV(SUB(maxh&,window_array&(index&,13)),window_array&(index&,10)),window_array&(index&,10))
~WIND_CALC(0,window_array&(index&,3),0,0,ADD(maxw&,window_array&(index&,12)),ADD(maxh&,window_array&(index&,13)),d&,d&,w&,h&)
ENDIF
ENDIF
RETURN
> FUNCTION win_limit_scroll(offset%,step&,limit!)
$F%
IF limit!
RETURN MUL(DIV(ADD(offset%,PRED(step&)),step&),step&)
ELSE
RETURN offset%
ENDIF
ENDFUNC
> PROCEDURE win_align(index&,VAR x&)
LOCAL xx&,d&
IF window_array&(index&,21)=-1
IF BTST(window_array&(index&,2),10)! window work area byte aligned
~WIND_CALC(1,window_array&(index&,3),x&,0,100,100,xx&,d&,d&,d&)
xx&=PRED(MUL(DIV(ADD(ADD(xx&,window_array&(index&,12)),4),8),8))
IF x&<0
ADD xx&,1
ELSE
IF xx&<0
ADD xx&,8
ENDIF
ENDIF
~WIND_CALC(0,window_array&(index&,3),SUB(xx&,window_array&(index&,12)),0,100,100,x&,d&,d&,d&)
ELSE IF BTST(window_array&(index&,2),11)! window work area word aligned
~WIND_CALC(1,window_array&(index&,3),x&,0,100,100,xx&,d&,d&,d&)
xx&=PRED(MUL(DIV(ADD(ADD(xx&,window_array&(index&,12)),8),16),16))
IF x&<0
ADD xx&,1
ELSE
IF xx&<0
ADD xx&,16
ENDIF
ENDIF
~WIND_CALC(0,window_array&(index&,3),SUB(xx&,window_array&(index&,12)),0,100,100,x&,d&,d&,d&)
ELSE
x&=@win_snap(x&)
ENDIF
ENDIF
RETURN
> PROCEDURE win_resize(index&,x&,y&,w&,h&)                                !call
LOCAL wx&,wy&,ww&,wh&
LOCAL off_x%,off_y%
IF window_array&(index&,21)=-1
~WIND_GET(window_array&(index&,0),5,wx&,wy&,ww&,wh&)
IF x&<>-1
LET wx&=x&
ENDIF
IF y&<>-1
LET wy&=y&
ENDIF
IF w&<>-1
LET ww&=w&
ENDIF
IF h&<>-1
LET wh&=h&
ENDIF
@win_align(index&,wx&)
@win_limit_size(index&,ww&,wh&)
~WIND_CALC(1,window_array&(index&,3),wx&,wy&,ww&,wh&,x&,y&,w&,h&)
ADD x&,window_array&(index&,12)
ADD y&,window_array&(index&,13)
SUB w&,window_array&(index&,12)
SUB h&,window_array&(index&,13)
LET off_x%=MAX(0,MIN(window_array%(index&,2),SUB(window_array%(index&,0),w&)))
LET off_y%=MAX(0,MIN(window_array%(index&,3),SUB(window_array%(index&,1),h&)))
@win_set_offset(index&,off_x%,off_y%)
~WIND_SET(window_array&(index&,0),5,wx&,wy&,ww&,wh&)
@win_set_sliders(index&)
IF BTST(window_array&(index&,2),0)
@win_place_tree(window_array&(index&,0))
ENDIF
IF BTST(window_array&(index&,2),4)
@win_get_workarea(index&,x&,y&,w&,h&)
@win_send_redraw(index&,x&,y&,w&,h&)
ENDIF
ELSE
~WIND_SET(window_array&(index&,0),5,x&,y&,w&,h&)
ENDIF
RETURN
> PROCEDURE redraw_userwindow(handle&,x&,y&,w&,h&)
LOCAL rx&,ry&,rw&,rh&,wx&,wy&,ww&,wh&,index&
LOCAL dx&,dy&,dw&,dh&
index&=@win_get_index(handle&)
@aes_screen_lock_only_screen
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
~WIND_GET(handle&,4,wx&,wy&,ww&,wh&)
IF BTST(window_array&(index&,2),0)
@win_place_tree(handle&)
IF BTST(window_array&(index&,2),5)
OB_W(window_tree%(index&,0),0)=ww&+window_array&(index&,15)
OB_W(window_tree%(index&,0),1)=ww&+window_array&(index&,15)
OB_W(window_tree%(index&,0),window_array&(index&,16))=ww&+window_array&(index&,15)
IF BTST(window_array&(index&,2),9)
OB_H(window_tree%(index&,0),window_array&(index&,16))=wh&-window_array&(index&,13)
ELSE
OB_H(window_tree%(index&,0),window_array&(index&,16))=1
ENDIF
ELSE
OB_W(window_tree%(index&,0),0)=ww&
OB_H(window_tree%(index&,0),0)=wh&
ENDIF
IF BTST(window_array&(index&,2),1)
OB_W(window_tree%(index&,0),1)=ww&
ELSE IF BTST(window_array&(index&,2),2)
OB_H(window_tree%(index&,0),1)=wh&
ENDIF
ENDIF
~WIND_GET(handle&,11,rx&,ry&,rw&,rh&)
WHILE rw& OR rh&
IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
IF window_array&(index&,21)<>-1
~OBJC_DRAW(window_tree%(index&,2),0,7,rx&,ry&,rw&,rh&)
ELSE
IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
@win_userwin_redraw_rect(index&,rx&,ry&,rw&,rh&)
ENDIF
ENDIF
ENDIF
~WIND_GET(handle&,12,rx&,ry&,rw&,rh&)
WEND
@aes_screen_unlock_only_screen
RETURN
> PROCEDURE window_message(ks&,m0&,m1&,m2&,m3&,m4&,m5&,m6&,m7&)
LOCAL index&,x&,y&,d&,w&,h&,offx%,offy%
LOCAL xstep&,ystep&
SELECT m0&
CASE 20
@redraw_userwindow(m3&,m4&,m5&,m6&,m7&)
CASE 22
index&=@win_get_index(m3&)
IF @user_win_close_ok(index&,window_array&(index&,8))
@win_close(m3&)
ENDIF
CASE 24
index&=@win_get_index(m3&)
@win_get_workarea(index&,d&,d&,w&,h&)
IF BTST(window_array&(index&,2),6)
LET xstep&=window_array&(index&,9)
LET ystep&=window_array&(index&,10)
ELSE
LET xstep&=MAX(1,w&\16)
LET ystep&=MAX(1,h&\16)
ENDIF
SELECT m4&
CASE 0
@win_set_offset(index&,-1,SUB(window_array%(index&,3),SUB(h&,ystep&)))
CASE 1
@win_set_offset(index&,-1,ADD(window_array%(index&,3),SUB(h&,ystep&)))
CASE 2
@win_set_offset(index&,-1,SUB(window_array%(index&,3),ystep&))
CASE 3
@win_set_offset(index&,-1,ADD(window_array%(index&,3),ystep&))
CASE 4
@win_set_offset(index&,SUB(window_array%(index&,2),SUB(w&,xstep&)),-1)
CASE 5
@win_set_offset(index&,ADD(window_array%(index&,2),SUB(w&,xstep&)),-1)
CASE 6
@win_set_offset(index&,SUB(window_array%(index&,2),xstep&),-1)
CASE 7
@win_set_offset(index&,ADD(window_array%(index&,2),xstep&),-1)
ENDSELECT
CASE 25
index&=@win_get_index(m3&)
~WIND_GET(m3&,4,x&,y&,w&,h&)
SUB w&,window_array&(index&,12)
IF w&<window_array%(index&,0)
offx%=ROUND(SUB(window_array%(index&,0),w&)*m4&/1000)
ELSE
offx%=0
ENDIF
IF offx%<>window_array%(index&,2)
@win_set_offset(index&,offx%,-1)
ENDIF
CASE 26
index&=@win_get_index(m3&)
~WIND_GET(m3&,4,x&,y&,w&,h&)
SUB h&,window_array&(index&,13)
IF h&<window_array%(index&,1)
offy%=ROUND(SUB(window_array%(index&,1),h&)*m4&/1000)
ELSE
offy%=0
ENDIF
IF offy%<>window_array%(index&,3)
@win_set_offset(index&,-1,offy%)
ENDIF
CASE 23
index&=@win_get_index(m3&)
~WIND_GET(0,4,x&,y&,w&,h&)
d&=x&
@win_align(index&,x&)
IF x&>d&
SUB w&,SUB(x&,d&)
ENDIF
@win_limit_size(index&,w&,h&)
~WIND_GET(m3&,5,m4&,m5&,m6&,m7&)
IF x&=m4& AND y&=m5& AND w&=m6& AND h&=m7&
~WIND_GET(m3&,6,m4&,m5&,m6&,m7&)
@win_align(index&,m4&)
@win_limit_size(index&,m6&,m7&)
@win_resize(index&,m4&,m5&,m6&,m7&)
ELSE
@win_resize(index&,x&,y&,w&,h&)
ENDIF
CASE 27
index&=@win_get_index(m3&)
@win_limit_size(index&,m6&,m7&)
@win_resize(index&,m4&,m5&,m6&,m7&)
CASE 28
index&=@win_get_index(m3&)
@win_align(index&,m4&)
@win_resize(index&,m4&,m5&,m6&,m7&)
CASE 33
index&=@win_get_index(m3&)
IF window_array&(index&,24)>0
~WIND_SET(m3&,25,0,0,0,0)
ENDIF
ENDSELECT
RETURN
> PROCEDURE win_set_offset(index&,off_x%,off_y%)                          !call
LOCAL rx&,ry&,rw&,rh&
LOCAL wx&,wy&,ww&,wh&
LOCAL off_x_alt%,off_y_alt%
LOCAL add_x%,add_y%
LOCAL dx&,dy&,dw&,dh&
@win_get_workarea(index&,wx&,wy&,ww&,wh&)
LET off_x_alt%=window_array%(index&,2)
LET off_y_alt%=window_array%(index&,3)
IF off_x%=-1
LET off_x%=off_x_alt%
ELSE
IF off_x%=-2
LET off_x%=MAX(0,SUB(window_array%(index&,0),ww&))
ELSE
LET off_x%=MAX(0,MIN(off_x%,SUB(window_array%(index&,0),ww&)))
ENDIF
LET off_x%=MAX(0,MIN(off_x%,SUB(window_array%(index&,0),ww&)))
LET off_x%=@win_limit_scroll(off_x%,window_array&(index&,9),BTST(window_array&(index&,2),6))
ENDIF
IF off_y%=-1
LET off_y%=off_y_alt%
ELSE
IF off_y%=-2
LET off_y%=MAX(0,SUB(window_array%(index&,1),wh&))
ELSE
LET off_y%=MAX(0,MIN(off_y%,SUB(window_array%(index&,1),wh&)))
ENDIF
LET off_y%=@win_limit_scroll(off_y%,window_array&(index&,10),BTST(window_array&(index&,2),6))
ENDIF
LET add_x%=SUB(off_x%,off_x_alt%)
LET add_y%=SUB(off_y%,off_y_alt%)
IF add_x%<>0 OR add_y%<>0
@aes_screen_lock_only_screen
IF BTST(window_array&(index&,2),8)
@do_all_redraws
ENDIF
LET window_array%(index&,2)=off_x%
LET window_array%(index&,3)=off_y%
CLIP OFF
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
~WIND_GET(window_array&(index&,0),11,rx&,ry&,rw&,rh&)
WHILE rw&<>0 OR rh&<>0
IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
IF RC_INTERSECT(wx&,wy&,ww&,wh&,rx&,ry&,rw&,rh&)
IF BTST(window_array&(index&,2),8)
@win_move_rect(index&,rx&,ry&,rw&,rh&,add_x%,add_y%)
ELSE
@win_userwin_redraw_rect(index&,rx&,ry&,rw&,rh&)
ENDIF
ENDIF
ENDIF
~WIND_GET(window_array&(index&,0),12,rx&,ry&,rw&,rh&)
WEND
@aes_screen_unlock_only_screen
@win_set_sliders(index&)
ENDIF
RETURN
> PROCEDURE win_userwin_redraw_rect(index&,x&,y&,w&,h&)
LOCAL wx&,wy&,ww&,wh&
IF w&>0 AND h&>0
IF BTST(window_array&(index&,2),0)
IF BTST(window_array&(index&,2),5)
~OBJC_DRAW(window_tree%(index&,0),1,7,x&,y&,w&,h&)
OB_TYPE(window_tree%(index&,0),window_array&(index&,16))=20
OB_SPEC(window_tree%(index&,0),window_array&(index&,16))=&HFF1101
~OBJC_DRAW(window_tree%(index&,0),window_array&(index&,16),0,x&,y&,w&,h&)
OB_TYPE(window_tree%(index&,0),window_array&(index&,16))=25
OB_SPEC(window_tree%(index&,0),window_array&(index&,16))=0
ELSE IF BTST(window_array&(index&,2),1) OR BTST(window_array&(index&,2),2)
IF BTST(window_array&(index&,2),9)
~OBJC_DRAW(window_tree%(index&,0),0,7,x&,y&,w&,h&)
ELSE
~OBJC_DRAW(window_tree%(index&,0),1,7,x&,y&,w&,h&)
ENDIF
ELSE IF BTST(window_array&(index&,2),9)
~OBJC_DRAW(window_tree%(index&,0),0,7,x&,y&,w&,h&)
ENDIF
ENDIF
CLIP x&,y&,w&,h& OFFSET 0,0
@user_rsc_draw_extra(window_array&(index&,8),index&,window_array&(index&,4),window_tree%(index&,0),x&,y&,w&,h&)
CLIP OFF
~WIND_GET(window_array&(index&,0),4,wx&,wy&,ww&,wh&)
ADD wx&,window_array&(index&,12)
ADD wy&,window_array&(index&,13)
SUB ww&,window_array&(index&,12)
SUB wh&,window_array&(index&,13)
IF RC_INTERSECT(wx&,wy&,ww&,wh&,x&,y&,w&,h&)
CLIP x&,y&,w&,h& OFFSET wx&,wy&
@user_window_content(index&,window_array&(index&,8),window_array%(index&,2),window_array%(index&,3),x&,y&,w&,h&)
ENDIF
ENDIF
RETURN
> PROCEDURE win_move_content(index&,sx%,sy%,dx%,dy%,w%,h%)                !call
LOCAL rx&,ry&,rw&,rh&
LOCAL wx&,wy&,ww&,wh&
LOCAL wx%,wy%,ww%,wh%
LOCAL add_x%,add_y%
LOCAL dx&,dy&,dw&,dh&
LET add_x%=SUB(sx%,dx%)
LET add_y%=SUB(sy%,dy%)
IF add_x%<>0 OR add_y%<>0
@win_get_workarea(index&,wx&,wy&,ww&,wh&)
LET wx%=SUB(ADD(MIN(sx%,dx%),wx&),window_array%(index&,2))
LET wy%=SUB(ADD(MIN(sy%,dy%),wy&),window_array%(index&,3))
LET ww%=ADD(w%,ABS(add_x%))
LET wh%=ADD(h%,ABS(add_y%))
IF RC_INTERSECT(wx%,wy%,ww%,wh%,wx&,wy&,ww&,wh&)
@aes_screen_lock_only_screen
@do_all_redraws
CLIP OFF
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
~WIND_GET(window_array&(index&,0),11,rx&,ry&,rw&,rh&)
WHILE rw&<>0 OR rh&<>0
IF RC_INTERSECT(dx&,dy&,dw&,dh&,rx&,ry&,rw&,rh&)
IF RC_INTERSECT(wx&,wy&,ww&,wh&,rx&,ry&,rw&,rh&)
@win_move_rect(index&,rx&,ry&,rw&,rh&,add_x%,add_y%)
ENDIF
ENDIF
~WIND_GET(window_array&(index&,0),12,rx&,ry&,rw&,rh&)
WEND
@aes_screen_unlock_only_screen
ENDIF
ENDIF
RETURN
> PROCEDURE win_move_rect(index&,x&,y&,w&,h&,add_x%,add_y%)
LOCAL sx&,sy&,sw&,sh&
LOCAL dx%,dy%,dw%,dh%
LOCAL r1x&,r1y&,r1w&,r1h&
LOCAL r2x&,r2y&,r2w&,r2h&
LET dx%=SUB(x&,add_x%)
LET dy%=SUB(y&,add_y%)
LET dw%=w&
LET dh%=h&
IF RC_INTERSECT(x&,y&,w&,h&,dx%,dy%,dw%,dh%) AND BTST(window_array&(index&,2),8)
LET sw&=WORD(dw%)
LET sh&=WORD(dh%)
IF add_x%>0
LET sx&=ADD(x&,add_x%)
LET r1x&=ADD(x&,sw&)
LET r1y&=y&
LET r1w&=add_x%
LET r1h&=h&
LET r2x&=x&
LET r2w&=sw&
ELSE
LET sx&=x&
LET r1x&=x&
LET r1y&=y&
LET r1w&=SUB(0,add_x%)
LET r1h&=h&
LET r2x&=SUB(x&,add_x%)
LET r2w&=sw&
ENDIF
IF add_y%>0
LET sy&=ADD(y&,add_y%)
LET r2y&=ADD(y&,sh&)
LET r2h&=add_y%
ELSE
LET sy&=y&
LET r2y&=y&
LET r2h&=SUB(0,add_y%)
ENDIF
@vdi_bitblt(0,0,0,0,0,0,0,0,0,0,sx&,sy&,sw&,sh&,dx%,dy%,1)
@win_userwin_redraw_rect(index&,r1x&,r1y&,r1w&,r1h&)
@win_userwin_redraw_rect(index&,r2x&,r2y&,r2w&,r2h&)
ELSE
@win_userwin_redraw_rect(index&,x&,y&,w&,h&)
ENDIF
RETURN
> PROCEDURE vdi_bitblt(sadr%,sw&,sh&,sf&,sbp&,dadr%,dw&,dh&,df&,dbp&,x&,y&,w&,h&,dx&,dy&,mod&) !call
LOCAL go%
IF sadr%=0
x&=MAX(x&,0)
y&=MAX(y&,0)
w&=MIN(w&,SUCC(SUB(WORK_OUT(0),x&)))
h&=MIN(h&,SUCC(SUB(WORK_OUT(1),y&)))
ELSE IF dadr%=0
dx&=MAX(dx&,0)
dy&=MAX(dy&,0)
w&=MIN(w&,SUCC(SUB(WORK_OUT(0),dx&)))
h&=MIN(h&,SUCC(SUB(WORK_OUT(1),dy&)))
ENDIF
go%=ADD(faceval_sys%,INT{ADD(faceval_sys%,16)})
IF w&>0 AND h&>0
IF sadr%=0 OR dadr%=0
~GRAF_MOUSE(256,0)
ENDIF
~C:go%(L:sadr%,sw&,sh&,sf&,sbp&,L:dadr%,dw&,dh&,df&,dbp&,x&,y&,w&,h&,dx&,dy&,mod&)
IF sadr%=0 OR dadr%=0
~GRAF_MOUSE(257,0)
ENDIF
ENDIF
RETURN
> PROCEDURE mouse_busy(object&)                                           !call
LOCAL tree%,next&
tree%=@xrsrc_gaddr(0,fvt_maus&)
IF object&>1 AND BYTE(OB_TYPE(tree%,object&))=25
next&=SUCC(BYTE(SHR&(OB_TYPE(tree%,object&),8)))
IF OB_NEXT(tree%,ADD(next&,object&))=object&
OB_TYPE(tree%,object&)=BYTE(OB_TYPE(tree%,object&))
ELSE
OB_TYPE(tree%,object&)=OR(SHL&(next&,8),BYTE(OB_TYPE(tree%,object&)))
ENDIF
@mouse_form(ADD(next&,object&))
ENDIF
RETURN
> PROCEDURE aes_clear_buffers                                             !call
WHILE BTST(EVNT_MULTI(&X100010,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3),1)
WEND
WHILE BTST(EVNT_MULTI(&X100001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50),0)
WEND
RETURN
> PROCEDURE mouse_form(object&)                                           !call
LOCAL tree%
IF object&=-1
~GRAF_MOUSE(0,0)
ELSE
tree%=@xrsrc_gaddr(0,fvt_maus&)
IF object&>1 AND BYTE(OB_TYPE(tree%,object&))=31
WORD{{OB_SPEC(tree%,1)}}=BYTE(SHR&(OB_TYPE(tree%,object&),12))
WORD{ADD({OB_SPEC(tree%,1)},2)}=AND(BYTE(SHR&(OB_TYPE(tree%,object&),8)),&X1111)
WORD{ADD({OB_SPEC(tree%,1)},4)}=1
WORD{ADD({OB_SPEC(tree%,1)},6)}=AND(BYTE(SHR&(WORD{ADD(OB_SPEC(tree%,object&),12)},8)),&X1111)
WORD{ADD({OB_SPEC(tree%,1)},8)}=BYTE(SHR&(WORD{ADD(OB_SPEC(tree%,object&),12)},12))
BMOVE LONG{OB_SPEC(tree%,object&)},ADD(LONG{OB_SPEC(tree%,1)},10),32
BMOVE LONG{ADD(OB_SPEC(tree%,object&),4)},ADD(LONG{OB_SPEC(tree%,1)},42),32
~GRAF_MOUSE(255,LONG{OB_SPEC(tree%,1)})
ENDIF
ENDIF
RETURN
> PROCEDURE progress_open(title$,break!)                                  !call
LOCAL tree%
tree%=@xrsrc_gaddr(0,fvt_prog&)
@rsc_set_text(fvt_prog&,5,title$)
CHAR{{OB_SPEC(tree%,3)}}="0"
CHAR{{ADD(4,OB_SPEC(tree%,3))}}="_%"
OB_STATE(tree%,4)=BCLR(OB_STATE(tree%,4),0)
OB_X(tree%,3)=0
@size_busy_progress_dialog(tree%,break!)
progress_handle&=@win_open_dialog(1,fvt_prog&,-1)
IF progress_handle&=0
@aes_screen_lock
~GRAF_MOUSE(2,0)
LET progress_busymouse!=TRUE
ENDIF
RETURN
> FUNCTION progress_update(value&)                                        !call
$F%
$F%
LOCAL event&,mx&,my&,mb&,ks&,key&,mc&,ret!,x&,x2&,y&,index&
ret!=FALSE
IF progress_handle&
index&=@win_get_index(progress_handle&)
IF index&<>-1
IF value&<>VAL(CHAR{{OB_SPEC(window_tree%(index&,0),3)}})
~OBJC_OFFSET(window_tree%(index&,0),3,x&,y&)
OB_X(window_tree%(index&,0),3)=INT(((OB_W(window_tree%(index&,0),2)-OB_W(window_tree%(index&,0),3))*value&)/100)
CHAR{{OB_SPEC(window_tree%(index&,0),3)}}=STR$(value&)
CHAR{{ADD(OB_SPEC(window_tree%(index&,0),3),4)}}=STRING$(LEN(STR$(value&)),"_")+"%"
~OBJC_OFFSET(window_tree%(index&,0),3,x2&,y&)
busy_progress_redraw(window_tree%(index&,0),index&)
ENDIF
ENDIF
DO
event&=EVNT_MULTI(&X110011,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,mx&,my&,mb&,ks&,key&,mc&)
IF BTST(event&,0)
ret!=@busy_progress_exited_keyb(key&,ks&)
ENDIF
IF BTST(event&,1) AND mb&=1
ret!=@busy_progress_exited_mouse(mx&,my&,mc&)
ENDIF
IF BTST(event&,4)
@main_message(mx&,my&,mc&,ks&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
ENDIF
LOOP UNTIL BTST(event&,5)
ENDIF
RETURN ret!
ENDFUNC
> PROCEDURE progress_close                                                !call
IF progress_handle&
@win_close(progress_handle&)
progress_handle&=0
ELSE IF progress_busymouse!
~GRAF_MOUSE(0,0)
WHILE BTST(EVNT_MULTI(&X100010,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3),1)
WEND
WHILE BTST(EVNT_MULTI(&X100001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50),0)
WEND
@aes_screen_unlock
CLR progress_busymouse!
ENDIF
RETURN
> PROCEDURE busy_progress_redraw(tree%,index&)
LOCAL x1&,y1&,w1&,h1&   ! slider background (left)
LOCAL x2&,y2&,w2&,h2&   ! slider itself
LOCAL lx&,ly&,lw&,lh&   ! redrawarea (left)
LOCAL mx&,my&,mw&,mh&   ! redrawarea (slider)
LOCAL handle&,tree%
LOCAL dx&,dy&,dw&,dh&
IF index&<>-1
@aes_screen_lock_only_screen
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
handle&=window_array&(index&,0)
@rsc_ob_xywh(window_tree%(index&,0),2,x1&,y1&,w1&,h1&)
@rsc_ob_xywh(window_tree%(index&,0),3,x2&,y2&,w2&,h2&)
LET w1&=SUB(x2&,x1&)
~WIND_GET(handle&,11,mx&,my&,mw&,mh&)
WHILE mw& OR mh&
IF RC_INTERSECT(dx&,dy&,dw&,dh&,mx&,my&,mw&,mh&)
LET lx&=mx&
LET ly&=my&
LET lw&=mw&
LET lh&=mh&
IF RC_INTERSECT(x2&,y2&,w2&,h2&,mx&,my&,mw&,mh&)
~OBJC_DRAW(window_tree%(index&,0),3,1,mx&,my&,mw&,mh&)
ENDIF
IF RC_INTERSECT(x1&,y1&,w1&,h1&,lx&,ly&,lw&,lh&)
~OBJC_DRAW(window_tree%(index&,0),2,1,lx&,ly&,lw&,lh&)
ENDIF
ENDIF
~WIND_GET(handle&,12,mx&,my&,mw&,mh&)
WEND
@aes_screen_unlock_only_screen
ENDIF
RETURN
> PROCEDURE size_busy_progress_dialog(tree%,break!)
LOCAL wchar&,hchar&,a&
LOCAL button&
~GRAF_HANDLE(wchar&,hchar&,a&,a&)
LET button&=4
IF break!
OB_FLAGS(tree%,button&)=BCLR(OB_FLAGS(tree%,button&),7)
OB_STATE(tree%,button&)=BCLR(OB_STATE(tree%,button&),3)
OB_H(tree%,0)=ADD(ADD(OB_Y(tree%,button&),OB_H(tree%,button&)),hchar&)
ELSE
OB_FLAGS(tree%,button&)=BSET(OB_FLAGS(tree%,button&),7)
OB_STATE(tree%,button&)=BSET(OB_STATE(tree%,button&),3)
OB_H(tree%,0)=OB_Y(tree%,button&)
ENDIF
RETURN
> FUNCTION busy_progress_exited_mouse(mx&,my&,mc&)
$F%
$F%
LOCAL handle&,d&,index&,object&
IF WIND_FIND(mx&,my&)=progress_handle&
~WIND_GET(0,10,handle&,d&,d&,d&)
IF handle&=progress_handle&
index&=@win_get_index(handle&)
IF index&<>-1
@win_place_tree(window_array&(index&,0))
object&=OBJC_FIND(window_tree%(index&,0),0,7,mx&,my&)
IF object&=4
IF @my_form_button(index&,object&,mc&)
RETURN TRUE
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN FALSE
ENDFUNC
> FUNCTION busy_progress_exited_keyb(key&,ks&)
$F%
$F%
LOCAL handle&,d&,index&
~WIND_GET(0,10,handle&,d&,d&,d&)
IF handle&=progress_handle&
index&=@win_get_index(handle&)
IF index&<>-1
IF NOT BTST(OB_FLAGS(window_tree%(index&,0),4),7)
IF NOT BTST(OB_STATE(window_tree%(index&,0),4),3)
IF BYTE(SHR(key&,8))=97 AND BTST(OB_FLAGS(window_tree%(index&,0),4),14)
OB_STATE(window_tree%(index&,0),4)=BSET(OB_STATE(window_tree%(index&,0),4),0)
@rsc_ob_draw(index&,4)
RETURN TRUE
ENDIF
IF BTST(ks&,3)
IF BYTE(OB_TYPE(window_tree%(index&,0),4))=24 AND (BYTE(SHR&(OB_TYPE(window_tree%(index&,0),4),8))=26 OR BYTE(SHR&(OB_TYPE(window_tree%(index&,0),4),8))=28)
IF @dialog_shortcuts_getob(index&,FALSE,@keyascii(key&),d&)
OB_STATE(window_tree%(index&,0),4)=BSET(OB_STATE(window_tree%(index&,0),4),0)
@rsc_ob_draw(index&,4)
RETURN TRUE
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN FALSE
ENDFUNC
> FUNCTION busy_open(break!)                                              !call
$F%
LOCAL tree%,index&,time&
tree%=@xrsrc_gaddr(0,fvt_work&)
animation_timer%=TIMER
OB_STATE(tree%,4)=BCLR(OB_STATE(tree%,4),0)
@size_busy_progress_dialog(tree%,break!)
progress_handle&=@win_open_dialog(1,fvt_work&,-1)
IF progress_handle&
ELSE
@aes_screen_lock
~GRAF_MOUSE(2,0)
LET progress_busymouse!=TRUE
ENDIF
RETURN FALSE
ENDFUNC
> PROCEDURE busy_close                                                    !call
IF progress_handle&
@win_close(progress_handle&)
progress_handle&=0
ELSE IF progress_busymouse!
~GRAF_MOUSE(0,0)
WHILE BTST(EVNT_MULTI(&X100010,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3),1)
WEND
WHILE BTST(EVNT_MULTI(&X100001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50),0)
WEND
@aes_screen_unlock
CLR progress_busymouse!
ENDIF
RETURN
> FUNCTION busy_update(time&)                                             !call
$F%
LOCAL event&,mx&,my&,mb&,ks&,key&,mc&,ret!,index&
ret!=FALSE
IF progress_handle&
DO
event&=EVNT_MULTI(&X110011,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,mx&,my&,mb&,ks&,key&,mc&)
IF BTST(event&,0)
ret!=@busy_progress_exited_keyb(key&,ks&)
ENDIF
IF BTST(event&,1)
ret!=@busy_progress_exited_mouse(mx&,my&,mc&)
ENDIF
IF BTST(event&,4)
@main_message(mx&,my&,mc&,ks&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
ENDIF
LOOP UNTIL BTST(event&,5)
ENDIF
RETURN ret!
ENDFUNC
> FUNCTION animate_icon(index&,a_object&)
$F%
LOCAL tree&,tree%,x&,y&,w&,h&,last&,num&,handle&,top&,nodraw!,buf$
LOCAL old_x&,old_y&,old_w&,old_h&,ret&,b%
handle&=window_array&(index&,0)
IF index&<>-1
~WIND_GET(0,10,top&,x&,x&,x&)
IF top&=handle& OR animate_background_alert!
tree&=BYTE(SHR&(OB_TYPE(window_tree%(index&,0),a_object&),8))
IF tree&
IF @ob_state(window_array&(index&,4),a_object&,13) AND NOT @ob_state(window_array&(index&,4),a_object&,10)
IF BTST(OB_STATE(window_tree%(index&,0),a_object&),0)
OB_STATE(window_tree%(index&,0),a_object&)=BCLR(OB_STATE(window_tree%(index&,0),a_object&),0)
ELSE
OB_STATE(window_tree%(index&,0),a_object&)=BSET(OB_STATE(window_tree%(index&,0),a_object&),0)
ENDIF
ELSE IF @ob_state(window_array&(index&,4),a_object&,14) AND NOT @ob_state(window_array&(index&,4),a_object&,10)
IF OB_TYPE(window_array&(index&,4),a_object&)=23
buf$=SPACE$(16)
BMOVE LONG{OB_SPEC(window_tree%(index&,0),a_object&)}+112,V:buf$,16
BMOVE LONG{OB_SPEC(window_tree%(index&,0),a_object&)},LONG{OB_SPEC(window_tree%(index&,0),a_object&)}+16,112
BMOVE V:buf$,LONG{OB_SPEC(window_tree%(index&,0),a_object&)},16
ENDIF
ELSE IF @ob_state(window_array&(index&,4),a_object&,15) AND NOT @ob_state(window_array&(index&,4),a_object&,10)
IF OB_TYPE(window_array&(index&,4),a_object&)=23
buf$=SPACE$(16)
BMOVE LONG{OB_SPEC(window_tree%(index&,0),a_object&)},V:buf$,16
BMOVE LONG{OB_SPEC(window_tree%(index&,0),a_object&)}+16,LONG{OB_SPEC(window_tree%(index&,0),a_object&)},112
BMOVE V:buf$,LONG{OB_SPEC(window_tree%(index&,0),a_object&)}+112,16
ENDIF
ELSE
tree%=@xrsrc_gaddr(0,tree&)
last&=VAL(CHAR{OB_SPEC(tree%,1)})
num&=VAL(CHAR{OB_SPEC(tree%,3)})
~OBJC_OFFSET(window_tree%(index&,0),a_object&,old_x&,old_y&)
SELECT BYTE(OB_TYPE(window_tree%(index&,0),a_object&))
CASE 23
old_w&=MUL(WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},8)
old_h&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),6)}
CASE 24
old_w&=WORD{ADD(LONG{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},22)}
old_h&=WORD{ADD(LONG{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},24)}
CASE 31,33
old_w&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),22)}
old_h&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),24)}
ENDSELECT
IF BYTE(SHR&(OB_TYPE(tree%,num&),8))<>0 AND BYTE(SHR&(OB_TYPE(tree%,num&),8))>BYTE(SHR&(OB_TYPE(tree%,2),8)) AND BTST(OB_STATE(tree%,num&),3)=TRUE
IF BYTE(SHR&(OB_TYPE(tree%,2),8))<>0
nodraw!=TRUE
ENDIF
OB_TYPE(tree%,2)=OR(SHL&(SUCC(BYTE(SHR&(OB_TYPE(tree%,2),8))),8),BYTE(OB_TYPE(tree%,2)))
ELSE
OB_TYPE(tree%,2)=BYTE(OB_TYPE(tree%,2))
IF @ob_state(window_array&(index&,4),a_object&,11)=FALSE
IF BTST(OB_STATE(tree%,1),0)
IF BTST(OB_STATE(tree%,1),1)
DEC num&
IF num&<4
OB_STATE(tree%,1)=BCLR(OB_STATE(tree%,1),1)
num&=5
ENDIF
ELSE
INC num&
IF num&>last&
OB_STATE(tree%,1)=BSET(OB_STATE(tree%,1),1)
num&=PRED(last&)
ENDIF
ENDIF
ELSE
INC num&
IF num&>last&
IF BTST(OB_STATE(tree%,1),3) AND BTST(OB_STATE(tree%,1),4)=FALSE
num&=last&
nodraw!=TRUE
ret&=-1
ELSE
num&=4
ENDIF
ENDIF
ENDIF
ELSE IF @ob_state(window_array&(index&,4),a_object&,10)
IF num&=3
num&=PRED(last&)
ELSE
DEC num&
ENDIF
IF num&<4
num&=4
nodraw!=TRUE
ret&=-2
ENDIF
ENDIF
buf$=STR$(num&,2)+CHR$(0)
BMOVE V:buf$,OB_SPEC(tree%,3),3
OB_TYPE(window_tree%(index&,0),a_object&)=(OB_TYPE(window_tree%(index&,0),a_object&) AND &HFF00) OR BYTE(OB_TYPE(tree%,num&))
OB_SPEC(window_tree%(index&,0),a_object&)=OB_SPEC(tree%,num&)
OB_W(window_tree%(index&,0),a_object&)=OB_W(tree%,num&)
OB_H(window_tree%(index&,0),a_object&)=OB_H(tree%,num&)
IF BTST(OB_STATE(tree%,1),4) AND nodraw!=FALSE
IF @ob_state(tree&,1,14)
IF OB_Y(window_tree%(index&,0),a_object&)<OB_H(window_tree%(index&,0),0)
OB_Y(window_tree%(index&,0),a_object&)=ADD(OB_Y(window_tree%(index&,0),a_object&),OB_Y(tree%,1))
ELSE
IF BTST(OB_STATE(tree%,1),3)
nodraw!=TRUE
ELSE
OB_Y(window_tree%(index&,0),a_object&)=-OB_H(tree%,num&)
ENDIF
ENDIF
ELSE
IF OB_X(window_tree%(index&,0),a_object&)<OB_W(window_tree%(index&,0),0)
OB_X(window_tree%(index&,0),a_object&)=ADD(OB_X(window_tree%(index&,0),a_object&),OB_X(tree%,1))
ELSE
IF BTST(OB_STATE(tree%,1),3)
nodraw!=TRUE
ELSE
OB_X(window_tree%(index&,0),a_object&)=-OB_W(tree%,num&)
ENDIF
ENDIF
ENDIF
ENDIF
IF NOT animate_sound_off!
IF BYTE(SHR&(OB_TYPE(tree%,num&),8))
IF @get_cookie("_SND",b%)
IF BTST(b%,1)
w&=WORD{ADD(OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8))),4)}
h&=WORD{ADD(OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8))),6)}
@dmasound(LONG{OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8)))},ADD(LONG{OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8)))},MUL(w&,h&)),BYTE(SHR&(OB_TYPE(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8))),8)),0)
@dmasound(LONG{OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8)))},ADD(LONG{OB_SPEC(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8)))},MUL(w&,h&)),BYTE(SHR&(OB_TYPE(tree%,BYTE(SHR&(OB_TYPE(tree%,num&),8))),8)),1)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF NOT nodraw!
~OBJC_OFFSET(window_tree%(index&,0),a_object&,x&,y&)
SELECT BYTE(OB_TYPE(window_tree%(index&,0),a_object&))
CASE 23
w&=MUL(WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},8)
h&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),6)}
CASE 24
w&=WORD{ADD(LONG{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},22)}
h&=WORD{ADD(LONG{ADD(OB_SPEC(window_tree%(index&,0),a_object&),4)},24)}
CASE 31,33
w&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),22)}
h&=WORD{ADD(OB_SPEC(window_tree%(index&,0),a_object&),24)}
ENDSELECT
w&=SUB(MAX(ADD(x&,w&),ADD(old_x&,old_w&)),MIN(x&,old_x&))
x&=MIN(x&,old_x&)
h&=SUB(MAX(ADD(y&,h&),ADD(old_y&,old_h&)),MIN(y&,old_y&))
y&=MIN(y&,old_y&)
IF window_array&(index&,0)=0
~FORM_DIAL(3,0,0,0,0,x&,y&,w&,h&)
ELSE
@win_send_redraw(index&,x&,y&,w&,h&)
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
RETURN ret&
ENDFUNC
> FUNCTION is_the_icon_animated(index&,reset!,object&,VAR time&)
$F%
LOCAL tree&,tree%
IF index&<>-1
tree&=BYTE(SHR&(OB_TYPE(window_tree%(index&,0),object&),8))
IF tree&
IF @ob_state(window_array&(index&,4),object&,13) OR @ob_state(window_array&(index&,4),object&,14) OR @ob_state(window_array&(index&,4),object&,15)
time&=tree&
RETURN TRUE
ELSE
tree%=@xrsrc_gaddr(0,tree&)
time&=VAL(CHAR{OB_SPEC(tree%,2)})
IF reset!
IF BTST(OB_STATE(tree%,1),4)
IF @ob_state(tree&,1,14)
OB_Y(window_tree%(index&,0),object&)=-OB_H(tree%,4)
ELSE
OB_X(window_tree%(index&,0),object&)=-OB_W(tree%,4)
ENDIF
ENDIF
CHAR{OB_SPEC(tree%,3)}=STR$(3)+CHR$(0)
ENDIF
RETURN TRUE
ENDIF
ENDIF
ENDIF
RETURN FALSE
ENDFUNC
> PROCEDURE dmasound(st_adr%,end_adr%,rate|,mode|)                        !call
SDPOKE &HFF8902,BYTE{SUCC(V:st_adr%)}
SDPOKE &HFF8904,BYTE{ADD(V:st_adr%,2)}
SDPOKE &HFF8906,BYTE{ADD(V:st_adr%,3)}
SDPOKE &HFF890E,BYTE{SUCC(V:end_adr%)}
SDPOKE &HFF8910,BYTE{ADD(V:end_adr%,2)}
SDPOKE &HFF8912,BYTE{ADD(V:end_adr%,3)}
SDPOKE &HFF8920,rate|
SDPOKE &HFF8900,mode|
RETURN
> PROCEDURE animicon_background(do_redraws!)
IF animicon_endtime%<>0
IF TIMER>=animicon_endtime%
~@animate_icon(animicon_index&,animicon_object&)
ADD animicon_endtime%,animicon_space%
IF do_redraws!
@do_all_redraws
ENDIF
IF TIMER>=animicon_endtime%
LET animicon_endtime%=ADD(TIMER,animicon_space%)
ENDIF
ENDIF
ENDIF
RETURN
> FUNCTION closer_object(handle&)
$F%
LOCAL a&,index&
index&=@win_get_index(handle&)
IF index&<>-1
a&=0
DO
INC a&
IF @ob_flags(window_array&(index&,4),a&,14)
IF BTST(OB_FLAGS(window_tree%(index&,0),a&),7)
@user_rsc_interact(index&,window_array&(index&,4),a&,1,0)
ELSE
@my_form_do2(0,index&,a&,-1)
ENDIF
RETURN TRUE
ENDIF
LOOP UNTIL BTST(OB_FLAGS(window_tree%(index&,0),a&),5)
ENDIF
RETURN FALSE
ENDFUNC
> PROCEDURE win_ascii_click(handle&,mx&,my&)
LOCAL wchar&,hchar&,d&,x&,y&
~WIND_GET(handle&,4,x&,y&,d&,d&)
@mouse_wait_realtime
@win_close(handle&)
~GRAF_HANDLE(wchar&,hchar&,d&,d&)
ADD x&,DIV(wchar&,2)
ADD y&,DIV(hchar&,2)
d&=1
IF RC_INTERSECT(x&,y&,MUL(MUL(wchar&,2),16),MUL(hchar&,10),mx&,my&,d&,d&)
d&=ADD(INT(DIV(SUB(mx&,x&),MUL(wchar&,2))),INT(MUL(DIV(SUB(my&,y&),hchar&),16)))
SELECT d&
CASE 0
d&=127
CASE 32 TO 159
ADD d&,96
ENDSELECT
@keypress(d&)
ENDIF
RETURN
> PROCEDURE cursor_on(index&)
LOCAL ob_spec%,a&
ob_spec%=OB_SPEC(window_tree%(index&,0),window_array&(index&,2))
ob_spec%=ADD({ob_spec%},window_array&(index&,3))
a&=BYTE{ob_spec%}
BYTE{ob_spec%}=0
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),1,window_array&(index&,3))
BYTE{ob_spec%}=a&
RETURN
> FUNCTION form_keybd(tree%,curr_obj&,key&,VAR new_obj&,keyout&)
$F%
GCONTRL(0)=55
GCONTRL(1)=3
GCONTRL(2)=3
GCONTRL(3)=1
GCONTRL(4)=0
ADDRIN(0)=tree%
GINTIN(0)=curr_obj&
GINTIN(1)=key&
GINTIN(2)=curr_obj&
GEMSYS
new_obj&=GINTOUT(1)
keyout&=GINTOUT(2)
RETURN GINTOUT(0)
ENDFUNC
> PROCEDURE fgtext_input(k_state&,key&,index&)
LOCAL new_obj&,keyout&,a&,new_pos&,new_obj&,maxlen&,str1$
LOCAL ob&
IF index&<>-1
LET new_obj&=window_array&(index&,2)
LET a&=1
CLR keyout&
str1$=@rsc_get_text$(window_array&(index&,4),window_array&(index&,2))
IF (k_state& AND &X11)<>0 AND BYTE(SHR(key&,8))=75
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),0)
ELSE IF (k_state& AND &X11)<>0 AND BYTE(SHR(key&,8))=77
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),LEN(CHAR{{OB_SPEC(window_tree%(index&,0),window_array&(index&,2))+8}}))
ELSE IF BTST(k_state&,2) AND BYTE(SHR(key&,8))=115
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
LET new_pos&=window_array&(index&,3)
WHILE new_pos&>0 AND (MID$(str1$,new_pos&,1)=" " OR MID$(str1$,new_pos&,1)="," OR MID$(str1$,new_pos&,1)="@" OR MID$(str1$,new_pos&,1)=";")
DEC new_pos&
WEND
WHILE new_pos&>0 AND (MID$(str1$,new_pos&,1)<>" " AND MID$(str1$,new_pos&,1)<>"," AND MID$(str1$,new_pos&,1)<>"@" AND MID$(str1$,new_pos&,1)<>";")
DEC new_pos&
WEND
LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),new_pos&)
ELSE IF BTST(k_state&,2) AND BYTE(SHR(key&,8))=116
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
LET maxlen&=LEN(CHAR{{OB_SPEC(window_tree%(index&,0),window_array&(index&,2))+8}})
LET new_pos&=window_array&(index&,3)
DO
INC new_pos&
LOOP WHILE new_pos&<maxlen& AND (MID$(str1$,new_pos&,1)<>" " AND MID$(str1$,new_pos&,1)<>"," AND MID$(str1$,new_pos&,1)<>"@" AND MID$(str1$,new_pos&,1)<>";")
WHILE new_pos&<maxlen& AND (MID$(str1$,new_pos&,1)=" " OR MID$(str1$,new_pos&,1)="," OR MID$(str1$,new_pos&,1)="@" OR MID$(str1$,new_pos&,1)=";")
INC new_pos&
WEND
LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),PRED(new_pos&))
ELSE
LET a&=@form_keybd(window_tree%(index&,0),window_array&(index&,2),key&,new_obj&,keyout&)
ENDIF
ob&=window_array&(index&,2)
IF a&>0
IF BYTE(SHR(key&,8))<>28 AND BYTE(SHR(key&,8))<>114
IF new_obj&<>window_array&(index&,2)
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
window_array&(index&,2)=new_obj&
LET maxlen&=LEN(CHAR{{OB_SPEC(window_tree%(index&,0),window_array&(index&,2))+8}})
LET window_array&(index&,3)=@set_cursor(index&,window_array&(index&,3),MIN(maxlen&,window_array&(index&,3)))
ENDIF
ENDIF
IF keyout&<>0
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),keyout&,window_array&(index&,3),2,new_pos&)
window_array&(index&,3)=new_pos&
ENDIF
@rsc_read_tree(window_array&(index&,4),window_array&(index&,2))
IF @ob_state(window_array&(index&,4),window_array&(index&,2),15)
IF ob&=window_array&(index&,2) AND @ob_state(window_array&(index&,4),window_array&(index&,2),12)=FALSE
IF @rsc_get_text$(window_array&(index&,4),window_array&(index&,2))<>str1$
@user_rsc_interact(index&,window_array&(index&,4),ob&,1,key&)
ENDIF
ENDIF
ENDIF
ELSE
OB_STATE(window_tree%(index&,0),new_obj&)=BCLR(OB_STATE(window_tree%(index&,0),new_obj&),0)
@rsc_ob_draw(index&,new_obj&)
@user_rsc_interact(index&,window_array&(index&,4),new_obj&,1,0)
ENDIF
ENDIF
RETURN
> PROCEDURE fix_editcursor(handle&)
LOCAL x&,y&,w&,h&,index&
index&=@win_get_index(handle&)
IF index&<>-1
IF window_array&(index&,21)=-1
IF window_array&(index&,1)>0
IF window_array&(index&,2)<>0
@rsc_ob_xywh(window_tree%(index&,0),window_array&(index&,2),x&,y&,w&,h&)
~FORM_DIAL(3,0,0,0,0,x&,SUB(y&,5),w&,ADD(h&,10))
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
> FUNCTION click_set_cursor(index&,mx&,my&,idx&)
$F%
LOCAL x&,a&,i&,ob_spec%,a$,wchar&
ob_spec%=OB_SPEC(window_tree%(index&,0),window_array&(index&,2))
~OBJC_OFFSET(window_tree%(index&,0),window_array&(index&,2),x&,a&)
~GRAF_HANDLE(wchar&,a&,a&,a&)
a$=CHAR{{ADD(ob_spec%,4)}}
SELECT WORD{ADD(ob_spec%,16)}
CASE 0       !left
x&=DIV(SUB(mx&,x&),wchar&)
CASE 1       !right
x&=DIV(SUB(mx&,SUB(ADD(x&,OB_W(window_tree%(index&,0),window_array&(index&,2))),MUL(wchar&,LEN(a$)))),wchar&)
CASE 2       !center
x&=DIV(SUB(mx&,ADD(x&,DIV(OB_W(window_tree%(index&,0),window_array&(index&,2))-MUL(wchar&,LEN(a$)),2))),wchar&)
ENDSELECT
x&=MAX(x&,0)
i&=0
FOR a&=1 TO x&
IF MID$(a$,a&,1)="_"
INC i&
ENDIF
NEXT a&
SUB x&,(x&-i&)
RETURN @set_cursor(index&,idx&,x&)
ENDFUNC
> FUNCTION set_cursor(index&,idx&,x&)
$F%
LOCAL ob_spec%,a&
ob_spec%=OB_SPEC(window_tree%(index&,0),window_array&(index&,2))
ob_spec%=ADD({ob_spec%},x&)
a&=BYTE{ob_spec%}
BYTE{ob_spec%}=0
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,idx&,1,idx&)
BYTE{ob_spec%}=a&
RETURN idx&
ENDFUNC
> PROCEDURE rsc_set_text(tree&,object&,string$)                           !call
LOCAL tree%,obspec%,whitebak!,clear_flags!
LOCAL gout1&,gout2&,gout3&,gout4&
~@appl_xgetinfo(13,gout1&,gout2&,gout3&,gout4&)
LET whitebak!=BTST(gout4&,2)
tree%=@xrsrc_gaddr(0,tree&)
obspec%=ADD(faceval_sys%,INT{ADD(faceval_sys%,18)})
CHAR{C:obspec%(L:tree%,object&)}=string$
@update_prg_def_textob(FALSE,tree%,tree&,object&,whitebak!,clear_flags!)
RETURN
> FUNCTION rsc_get_text$(tree&,object&)                                   !call
LOCAL tree%,obspec%
tree%=@xrsrc_gaddr(0,tree&)
obspec%=ADD(faceval_sys%,INT{ADD(faceval_sys%,18)})
RETURN CHAR{C:obspec%(L:tree%,object&)}
ENDFUNC
> PROCEDURE rsc_set_radio(tree&,object&,value&,index&)
LOCAL tree%,root&,a&,b&,ob1&,ob2&
tree%=@xrsrc_gaddr(0,tree&)
IF BTST(OB_FLAGS(tree%,object&),4)
root&=object&
DO
root&=OB_NEXT(tree%,root&)
LOOP UNTIL root&<object&
a&=OB_HEAD(tree%,root&)
b&=1
DO
IF BTST(OB_FLAGS(tree%,a&),4)
IF BTST(OB_STATE(tree%,a&),0)
OB_STATE(tree%,a&)=BCLR(OB_STATE(tree%,a&),0)
ob1&=a&
ENDIF
IF b&=value&
OB_STATE(tree%,a&)=BSET(OB_STATE(tree%,a&),0)
ob2&=a&
ENDIF
INC b&
ENDIF
a&=OB_NEXT(tree%,a&)
LOOP UNTIL a&=root&
IF index&<>-1
IF ob1&<>0
@rsc_ob_draw(index&,ob1&)
ENDIF
IF ob2&<>0
@rsc_ob_draw(index&,ob2&)
ENDIF
ENDIF
ENDIF
RETURN
> FUNCTION rsc_get_radio(tree&,object&)
$F%
LOCAL tree%,root&,a&,b&
tree%=@xrsrc_gaddr(0,tree&)
IF BTST(OB_FLAGS(tree%,object&),4)
root&=object&
DO
root&=OB_NEXT(tree%,root&)
LOOP UNTIL root&<object&
a&=OB_HEAD(tree%,root&)
b&=1
DO
IF BTST(OB_FLAGS(tree%,a&),4)
IF BTST(OB_STATE(tree%,a&),0)
RETURN b&
ENDIF
INC b&
ENDIF
a&=OB_NEXT(tree%,a&)
LOOP UNTIL a&=root&
ENDIF
RETURN 0
ENDFUNC
> PROCEDURE invert_pointer_string(index&,object&,flag!)
LOCAL x&,y&,w&,h&,rx&,ry&,rw&,rh&
IF PRED(object&)>0
IF @pointforward_object(index&,PRED(object&))
IF flag!
OB_STATE(window_tree%(index&,0),PRED(object&))=BSET(OB_STATE(window_tree%(index&,0),PRED(object&)),0)
OB_H(window_tree%(index&,0),PRED(object&))=OB_H(window_tree%(index&,0),PRED(object&))+4
OB_W(window_tree%(index&,0),PRED(object&))=SUB(OB_X(window_tree%(index&,0),object&),OB_X(window_tree%(index&,0),PRED(object&)))
ELSE
OB_STATE(window_tree%(index&,0),PRED(object&))=BCLR(OB_STATE(window_tree%(index&,0),PRED(object&)),0)
ENDIF
@rsc_ob_xywh(window_tree%(index&,0),PRED(object&),x&,y&,w&,h&)
~WIND_GET(window_array&(index&,0),11,rx&,ry&,rw&,rh&)
WHILE rw& OR rh&
IF RC_INTERSECT(x&,y&,w&,h&,rx&,ry&,rw&,rh&)
~OBJC_DRAW(window_tree%(index&,0),0,7,rx&,ry&,rw&,rh&)
ENDIF
~WIND_GET(window_array&(index&,0),12,rx&,ry&,rw&,rh&)
WEND
IF NOT flag!
OB_H(window_tree%(index&,0),PRED(object&))=OB_H(window_tree%(index&,0),PRED(object&))-4
ENDIF
ENDIF
ENDIF
RETURN
> FUNCTION popup(index&,object&,selected&)
$F%
LOCAL org_tree%,org_tree&,tree%,pop_me&,x&,y&,dx&,dy&,dw&,dh&,mx&,my&,mb&,ks&
LOCAL inv_obj&,result&,m!,evnt&,key&,mc&,ascii|,scan|,exit!,bp&,buffer%
org_tree%=window_tree%(index&,0)
org_tree&=window_array&(index&,4)
pop_me&=@popup_find(org_tree%,org_tree&,object&)
tree%=@xrsrc_gaddr(0,fvt_popu&)
IF @popup_enq_radio(org_tree%,object&)
IF BYTE(OB_TYPE(org_tree%,object&))=22
OB_STATE(tree%,ADD(selected&,pop_me&))=BSET(OB_STATE(tree%,ADD(selected&,pop_me&)),2)
ENDIF
ENDIF
~OBJC_OFFSET(org_tree%,object&,x&,y&)
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
OB_X(tree%,0)=MIN(MAX(SUB(x&,ADD(OB_X(tree%,pop_me&),OB_X(tree%,ADD(MAX(selected&,1),pop_me&)))),-OB_X(tree%,pop_me&)),SUB(SUB(PRED(ADD(dx&,dw&)),OB_X(tree%,pop_me&)),OB_W(tree%,pop_me&)))
OB_Y(tree%,0)=MIN(MAX(SUB(y&,ADD(OB_Y(tree%,pop_me&),OB_Y(tree%,ADD(MAX(selected&,1),pop_me&)))),SUB(dy&,OB_Y(tree%,pop_me&))),SUB(SUB(PRED(ADD(dy&,dh&)),OB_H(tree%,pop_me&)),OB_Y(tree%,pop_me&)))
~OBJC_OFFSET(tree%,pop_me&,x&,y&)
@aes_screen_lock
bp&=@vq_extnd(V~H,1,4)
buffer%=MALLOC(MUL(MUL(MUL(DIV(ADD(OB_W(tree%,pop_me&),20),16),2),ADD(OB_H(tree%,pop_me&),5)),bp&))
IF buffer%>0
IF BYTE(OB_TYPE(org_tree%,object&))=23
@invert_pointer_string(index&,PRED(object&),-1)
ELSE
@invert_pointer_string(index&,object&,-1)
ENDIF
fv_malloced%=buffer%
@vdi_bitblt(0,0,0,0,bp&,buffer%,ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5),0,bp&,PRED(x&),PRED(y&),ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5),0,0,1)
~OBJC_DRAW(tree%,pop_me&,7,PRED(x&),PRED(y&),ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5))
~GRAF_MKSTATE(mx&,my&,mb&,ks&)
inv_obj&=0
result&=OBJC_FIND(tree%,pop_me&,7,mx&,my&)
IF result&=>1 AND result&<>pop_me& AND BTST(OB_STATE(tree%,result&),3)=FALSE
~OBJC_OFFSET(tree%,result&,dx&,dy&)
~OBJC_CHANGE(tree%,result&,0,dx&,dy&,OB_W(tree%,result&),OB_H(tree%,result&),BSET(OB_STATE(tree%,result&),0),1)
inv_obj&=result&
ENDIF
~EVNT_TIMER(200)
~GRAF_MKSTATE(mx&,my&,mb&,ks&)
IF mb&=1
m!=TRUE
ENDIF
DO
IF m!
~GRAF_MKSTATE(mx&,my&,mb&,ks&)
ELSE
evnt&=EVNT_MULTI(&X111,1,1,1,1,mx&,my&,1,1,0,0,0,0,0,0,0,mx&,my&,mb&,ks&,key&,mc&)
ENDIF
IF BTST(evnt&,2) OR m!
result&=OBJC_FIND(tree%,pop_me&,7,mx&,my&)
IF result&=pop_me&
result&=-1
ENDIF
ENDIF
IF BTST(evnt&,0)                                 !keyboard
ascii|=BYTE(key&)
scan|=BYTE(SHR(key&,8))
IF scan|=71
IF AND(ks&,&X11) !shift
result&=OB_TAIL(tree%,pop_me&)
ELSE
result&=ADD(pop_me&,1)
ENDIF
ELSE IF scan|=80
IF result&<0
result&=ADD(pop_me&,1)
ELSE
IF AND(ks&,&X11) !shift
result&=OB_TAIL(tree%,pop_me&)
ELSE
result&=OB_NEXT(tree%,result&)
IF result&<=pop_me&
result&=ADD(pop_me&,1)
ENDIF
ENDIF
ENDIF
ELSE IF scan|=72
IF result&<0
result&=ADD(pop_me&,1)
ELSE
IF AND(ks&,&X11) !shift
result&=ADD(pop_me&,1)
ELSE
IF result&>ADD(pop_me&,1)
DEC result&
ELSE IF result&=ADD(pop_me&,1)
result&=OB_TAIL(tree%,pop_me&)
ENDIF
ENDIF
ENDIF
ELSE IF scan|=97 OR ascii|=27
result&=-1
exit!=TRUE
ELSE IF ascii|=13
exit!=TRUE
ENDIF
ENDIF
IF result&<>inv_obj&
IF inv_obj&=>1
~OBJC_OFFSET(tree%,inv_obj&,dx&,dy&)
~OBJC_CHANGE(tree%,inv_obj&,0,dx&,dy&,OB_W(tree%,inv_obj&),OB_H(tree%,inv_obj&),BCLR(OB_STATE(tree%,inv_obj&),0),1)
ENDIF
IF result&=>1
IF NOT BTST(OB_STATE(tree%,result&),3)
~OBJC_OFFSET(tree%,result&,dx&,dy&)
~OBJC_CHANGE(tree%,result&,0,dx&,dy&,OB_W(tree%,result&),OB_H(tree%,result&),BSET(OB_STATE(tree%,result&),0),1)
ENDIF
ENDIF
inv_obj&=result&
ENDIF
~EVNT_TIMER(20)
LOOP UNTIL BTST(evnt&,1) OR (mb&=0 AND m!) OR exit!
IF @popup_enq_radio(org_tree%,object&)
IF BYTE(OB_TYPE(org_tree%,object&))=22
OB_STATE(tree%,ADD(selected&,pop_me&))=BCLR(OB_STATE(tree%,ADD(selected&,pop_me&)),2)
ENDIF
ENDIF
@mouse_wait
~OBJC_OFFSET(tree%,pop_me&,x&,y&)
@vdi_bitblt(buffer%,ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5),0,bp&,0,0,0,0,bp&,0,0,ADD(OB_W(tree%,pop_me&),5),ADD(OB_H(tree%,pop_me&),5),PRED(x&),PRED(y&),1)
~MFREE(buffer%)
fv_malloced%=0
IF BYTE(OB_TYPE(org_tree%,object&))=23
@invert_pointer_string(index&,PRED(object&),0)
ELSE
@invert_pointer_string(index&,object&,0)
ENDIF
IF result&<>-1
IF NOT BTST(OB_STATE(tree%,result&),3)
OB_STATE(tree%,result&)=BCLR(OB_STATE(tree%,result&),0)
IF @popup_enq_radio(org_tree%,object&)
IF BYTE(OB_TYPE(org_tree%,object&))=22
{OB_SPEC(org_tree%,object&)}=OB_SPEC(tree%,result&)
@rsc_ob_draw(index&,object&)
ELSE
OB_SPEC(org_tree%,object&)=OB_SPEC(tree%,result&)
@rsc_ob_draw(index&,PRED(object&))
ENDIF
ENDIF
LET selected&=SUB(result&,pop_me&)
ENDIF
ENDIF
ENDIF
@aes_screen_unlock
RETURN selected&
ENDFUNC
> FUNCTION popup_cycle(index&,object&,selected&)
$F%
LOCAL tree2%,a&,num&,pop_me&
pop_me&=@popup_find(window_tree%(index&,0),window_array&(index&,4),object&)
tree2%=@xrsrc_gaddr(0,fvt_popu&)
num&=0
a&=OB_HEAD(tree2%,pop_me&)
DO
INC num&
a&=OB_NEXT(tree2%,a&)
LOOP UNTIL a&=pop_me&
a&=selected&
DO
INC a&
IF a&>num&
a&=1
ENDIF
IF BTST(OB_STATE(tree2%,ADD(pop_me&,a&)),3)=0
LET selected&=a&
EXIT IF TRUE
ENDIF
EXIT IF a&=selected&
LOOP
@popup_set_selected(window_array&(index&,4),object&,selected&,index&)
~EVNT_TIMER(100)
RETURN selected&
ENDFUNC
> FUNCTION popup_find(tree%,tree&,object&)
$F%
LOCAL tree2%,a&,pop_me&
tree2%=@xrsrc_gaddr(0,fvt_popu&)
a&=0
pop_me&=0
DO
INC pop_me&
IF BYTE(OB_TYPE(tree2%,pop_me&))=20
INC a&
ENDIF
LOOP UNTIL a&=SUB(BYTE(SHR&(OB_TYPE(tree%,object&),8)),30)
RETURN pop_me&
ENDFUNC
> FUNCTION popup_get_radio(tree&,object&)
$F%
LOCAL tree%,org_tree%,pop_me&,a&
org_tree%=@xrsrc_gaddr(0,tree&)
tree%=@xrsrc_gaddr(0,fvt_popu&)
pop_me&=@popup_find(org_tree%,tree&,object&)
IF BYTE(OB_TYPE(org_tree%,object&))=22
DO
INC a&
IF OB_SPEC(tree%,a&)={OB_SPEC(org_tree%,object&)}
RETURN SUB(a&,pop_me&)
ENDIF
LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
ELSE IF BYTE(OB_TYPE(org_tree%,object&))=23
DO
INC a&
IF OB_SPEC(tree%,a&)=OB_SPEC(org_tree%,object&)
RETURN SUB(a&,pop_me&)
ENDIF
LOOP UNTIL BTST(OB_FLAGS(tree%,a&),5)
ENDIF
RETURN 1
ENDFUNC
> PROCEDURE popup_set_selected(tree&,object&,value&,index&)
LOCAL tree2%,pop_me&,a&,sel&,tree%
tree%=@xrsrc_gaddr(0,tree&)
pop_me&=@popup_find(tree%,tree&,object&)
tree2%=@xrsrc_gaddr(0,fvt_popu&)
sel&=0
a&=OB_HEAD(tree2%,pop_me&)
DO
INC sel&
IF sel&=value&
IF BYTE(OB_TYPE(tree%,object&))=22
{OB_SPEC(tree%,object&)}=OB_SPEC(tree2%,a&)
IF index&<>-1
@rsc_ob_draw(index&,object&)
ENDIF
ELSE
OB_SPEC(tree%,object&)=OB_SPEC(tree2%,a&)
IF index&<>-1
@rsc_ob_draw(index&,PRED(object&))
ENDIF
ENDIF
EXIT IF TRUE
ENDIF
a&=OB_NEXT(tree2%,a&)
LOOP UNTIL a&=pop_me&
RETURN
> FUNCTION popup_enq_radio(tree%,object&)
$F%
IF NOT BTST(OB_FLAGS(tree%,object&),5)
IF BYTE(SHR&(OB_TYPE(tree%,SUCC(object&)),8))=27 OR BYTE(OB_TYPE(tree%,SUCC(object&)))=27
IF OB_NEXT(tree%,SUCC(object&))=object& OR OB_NEXT(tree%,SUCC(object&))=PRED(object&)
RETURN TRUE
ENDIF
ENDIF
ENDIF
RETURN FALSE
ENDFUNC
> FUNCTION popup_sub_formdo(index&,VAR object&)
$F%
LOCAL sub&
IF @ob_state(window_array&(index&,4),object&,10)=FALSE
IF BYTE(OB_TYPE(window_tree%(index&,0),object&))=22 AND BYTE(SHR&(OB_TYPE(window_tree%(index&,0),object&),8))>30
IF OB_HEAD(window_tree%(index&,0),object&)=-1
sub&=@popup(index&,object&,0)
ELSE
~@popup(index&,object&,@popup_get_radio(window_array&(index&,4),object&))
ENDIF
ELSE IF BYTE(SHR&(OB_TYPE(window_tree%(index&,0),PRED(object&)),8))>30 AND @ob_flags(window_array&(index&,4),object&,9)
IF BYTE(OB_TYPE(window_tree%(index&,0),PRED(object&)))=22
~@popup_cycle(index&,PRED(object&),@popup_get_radio(window_array&(index&,4),PRED(object&)))
DEC object&
ELSE IF BYTE(OB_TYPE(window_tree%(index&,0),PRED(object&)))=23
~@popup_cycle(index&,PRED(object&),@popup_get_radio(window_array&(index&,4),PRED(object&)))
DEC object&
ENDIF
ELSE IF BYTE(OB_TYPE(window_tree%(index&,0),object&))=23 AND BYTE(SHR&(OB_TYPE(window_tree%(index&,0),object&),8))>30
IF OB_NEXT(window_tree%(index&,0),object&)>object&
~@popup(index&,object&,@popup_get_radio(window_array&(index&,4),object&))
ELSE
sub&=@popup(index&,object&,0)
ENDIF
ENDIF
ENDIF
RETURN sub&
ENDFUNC
> PROCEDURE rsc_set_selectable(tree&,object&,flag&)
LOCAL tree%
tree%=@xrsrc_gaddr(0,tree&)
IF flag&
OB_STATE(tree%,object&)=BSET(OB_STATE(tree%,object&),0)
ELSE
OB_STATE(tree%,object&)=BCLR(OB_STATE(tree%,object&),0)
ENDIF
RETURN
> FUNCTION rsc_get_selectable(tree&,object&)
$F%
LOCAL tree%
tree%=@xrsrc_gaddr(0,tree&)
RETURN BTST(OB_STATE(tree%,object&),0)
ENDFUNC
> FUNCTION rs_read(fname$,VAR rsc%)
LOCAL size%
LOCAL ret!
LOCAL found!
LOCAL fh&
LET ret!=FALSE
LET found!=(SHEL_FIND(fname$)<>0)
IF found!
LET fname$=fname$+CHR$(0)
LET fh&=GEMDOS(61,L:V:fname$,0)
IF fh&=>0
LET size%=GEMDOS(66,L:0,fh&,2)
IF size%>72
rsc%=MALLOC(size%)
IF rsc%<>0
~GEMDOS(66,L:0,fh&,0)
IF GEMDOS(63,fh&,L:size%,L:rsc%)=size%
@rsc_fixup(rsc%,size%)
ret!=TRUE
ELSE
~MFREE(rsc%)
ENDIF
ENDIF
ENDIF
~GEMDOS(62,fh&)
ENDIF
ENDIF
RETURN ret!
ENDFUNC
> PROCEDURE rsc_fixup(rsc%,rs_len%)
LOCAL vgb_image_adress%
LOCAL vgb_string_adress%
LOCAL ob_start_adr%,tree_table%,object&,tree&,free_str_num&,free_img_num&
LOCAL version&,long!,end&
LOCAL c_icon%
LET version&=WORD{rsc%}
LET long!=(WORD{rsc%} AND &X10)=2
IF long!
tree_table%=rsc%+{rsc%+36}
ELSE
tree_table%=rsc%+CARD{rsc%+18}
ENDIF
IF long!
LET end&={rsc%+44}-1
ELSE
LET end&=CARD{rsc%+22}-1
ENDIF
FOR tree&=0 TO end&
{tree_table%+(4*tree&)}={tree_table%+(4*tree&)}+rsc%
NEXT tree&
IF long!
free_str_num&={rsc%+30*2}-1
ELSE
free_str_num&=CARD{rsc%+30}-1
ENDIF
IF free_str_num&>-1
IF long!
vgb_string_adress%=rsc%+{rsc%+10*2}
ELSE
vgb_string_adress%=rsc%+CARD{rsc%+10}
ENDIF
FOR object&=0 TO free_str_num&
{vgb_string_adress%+(4*object&)}={vgb_string_adress%+(4*object&)}+rsc%
NEXT object&
ENDIF
IF long!
free_img_num&={rsc%+32*2}-1
ELSE
free_img_num&=CARD{rsc%+32}-1
ENDIF
IF free_img_num&>-1
IF long!
vgb_image_adress%=rsc%+{rsc%+16*2}
ELSE
vgb_image_adress%=rsc%+CARD{rsc%+16}
ENDIF
FOR object&=0 TO free_img_num&
{vgb_image_adress%+(4*object&)}={vgb_image_adress%+(4*object&)}+rsc%
{{vgb_image_adress%+(4*object&)}}={{vgb_image_adress%+(4*object&)}}+rsc%
NEXT object&
ENDIF
IF long!
ob_start_adr%=rsc%+{rsc%+2*2}
ELSE
ob_start_adr%=rsc%+CARD{rsc%+2}
ENDIF
IF long!
LET end&={rsc%+20*2}-1
ELSE
LET end&=CARD{rsc%+20}-1
ENDIF
FOR object&=0 TO end&
~RSRC_OBFIX(ob_start_adr%,object&)
SELECT BYTE(OB_TYPE(ob_start_adr%,object&))
CASE 21,22,23,26,28,29,30,31,32,34,35,37,38
OB_SPEC(ob_start_adr%,object&)=OB_SPEC(ob_start_adr%,object&)+rsc%
ENDSELECT
SELECT BYTE(OB_TYPE(ob_start_adr%,object&))
CASE 23,34,35
{OB_SPEC(ob_start_adr%,object&)}={OB_SPEC(ob_start_adr%,object&)}+rsc%
CASE 21,22,29,30,31
{OB_SPEC(ob_start_adr%,object&)}={OB_SPEC(ob_start_adr%,object&)}+rsc%
{OB_SPEC(ob_start_adr%,object&)+4}={OB_SPEC(ob_start_adr%,object&)+4}+rsc%
{OB_SPEC(ob_start_adr%,object&)+8}={OB_SPEC(ob_start_adr%,object&)+8}+rsc%
ENDSELECT
NEXT object&
@rs_do_ciconfix(rsc%)
RETURN
> FUNCTION xrsrc_free(rsc%)
IF rsc%<>0
~MFREE(rsc%)
RETURN TRUE
ELSE
RETURN FALSE
ENDIF
ENDFUNC
> FUNCTION xrsrc_load(name$)
LOCAL rsc%
IF @rs_read(name$,rsc%)=0
LET rsc%=0
ENDIF
RETURN rsc%
ENDFUNC
> FUNCTION xrsrc_xgaddr(rsc%,type&,item&,VAR adr%)
IF rsc%<>0
adr%=@rs_get_address(rsc%,type&,item&)
ELSE
adr%=0
ENDIF
RETURN adr%<>0
ENDFUNC
> FUNCTION rs_get_address(rsc%,type&,index%)
LOCAL the_addr%,long!,version&
the_addr%=0
LET version&=WORD{rsc%}
LET long!=(version& AND &X10)=2
IF long!
SELECT type&
CASE 0
the_addr%={rsc%+{rsc%+36}+index%*4}
CASE 1
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+4},24)
CASE 2
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+8},28)
CASE 3
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+12},34)
CASE 4
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+16},14)
CASE 5
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+20},4)
CASE 6
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+28},4)
CASE 7
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+4}+12,24)
CASE 8
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+8},28)
CASE 9
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+8}+4,28)
CASE 10
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+8}+8,28)
CASE 11
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+12},34)
CASE 12
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+12}+4,34)
CASE 13
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+12}+8,34)
CASE 14
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+16},14)
CASE 15
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+20},4)
CASE 16
the_addr%=@rs_get_sub(index%,rsc%+{rsc%+32},4)
ENDSELECT
ELSE
SELECT type&
CASE 0
the_addr%={rsc%+CARD{rsc%+36\2}+index%*4}
CASE 1
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+4\2},24)
CASE 2
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+8\2},28)
CASE 3
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+12\2},34)
CASE 4
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+16\2},14)
CASE 5
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+20\2},4)
CASE 6
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+28\2},4)
CASE 7
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+4\2}+12,24)
CASE 8
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+8\2},28)
CASE 9
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+8\2}+4,28)
CASE 10
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+8\2}+8,28)
CASE 11
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+12\2},34)
CASE 12
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+12\2}+4,34)
CASE 13
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+12\2}+8,34)
CASE 14
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+16\2},14)
CASE 15
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+20\2},4)
CASE 16
the_addr%=@rs_get_sub(index%,rsc%+CARD{rsc%+32\2},4)
ENDSELECT
ENDIF
RETURN the_addr%
ENDFUNC
> FUNCTION rs_get_sub(index%,offset%,size%)
RETURN ADD(offset%,MUL(index%,size%))
ENDFUNC
> PROCEDURE rs_do_ciconfix(rsc%)
LOCAL i&,num&
LOCAL ciconblk%
LOCAL p%
LOCAL iclen%
LOCAL p2%
LOCAL cicon%
LOCAL num_cicon%
LOCAL i2%
LOCAL pobject%
LOCAL ob%
LOCAL rsxhdr4%
LOCAL rsxhdr24%
LOCAL rsxhdr40%
LOCAL rsxhdr68%
IF (version& AND &X10)=2
LET rsxhdr4%={rsc%+4}
LET rsxhdr24%={rsc%+24}
LET rsxhdr40%={rsc%+40}
LET rsxhdr68%={rsc%+68}
ELSE
LET rsxhdr4%=CARD{rsc%+4\2}
LET rsxhdr24%=CARD{rsc%+24\2}
LET rsxhdr40%=CARD{rsc%+40\2}
LET rsxhdr68%=CARD{rsc%+68\2}
ENDIF
LET cicon_liste%={rsxhdr68%+rsc%+4}+rsc%
num&=0
WHILE {cicon_liste%+num&*4}=0
INC num&
WEND
IF {cicon_liste%+num&*4}<>-1
LET num&=-1
ELSE
LET p%=cicon_liste%+(num&+1)*4
FOR i&=0 TO PRED(num&)
LET ciconblk%=p%
{cicon_liste%+i&*4}=ciconblk%
ADD p%,38
{ciconblk%+4}=p%
LET iclen%=((WORD{ciconblk%+22}+15)/16)
MUL iclen%,2*WORD{ciconblk%+24}
ADD p%,iclen%
{ciconblk%}=p%
ADD p%,iclen%
LET p2%={ciconblk%+8}
IF (p2%=0) OR (p2%<rsxhdr24%) OR (p2%>rsxhdr68%)
{ciconblk%+8}=p%
ELSE
{ciconblk%+8}=rsc%+p2%
ENDIF
ADD p%,12
num_cicon%={ciconblk%+34}
FOR i2%=0 TO PRED(num_cicon%)
LET cicon%=p%
ADD p%,22
ADD p%,iclen%*WORD{cicon%}
ADD p%,iclen%
IF {cicon%+10}<>0
ADD p%,iclen%*WORD{cicon%}
ADD p%,iclen%
ENDIF
NEXT i2%
NEXT i&
pobject%=rsc%+rsxhdr4%
FOR ob%=0 TO PRED(rsxhdr40%)
IF BYTE(OB_TYPE(pobject%,ob%))=33
OB_TYPE(pobject%,ob%)=OR(AND(OB_TYPE(pobject%,ob%),&HFF00),31)
OB_SPEC(pobject%,ob%)={cicon_liste%+OB_SPEC(pobject%,ob%)*4}
ENDIF
NEXT ob%
ENDIF
RETURN
> PROCEDURE win_change_size(index&,new_w%,new_h%,step_x&,step_y&,zero!)   !call
LOCAL x&,y&,w&,h&                                     !local variables
@win_get_workarea(index&,x&,y&,w&,h&)                 !get work area of window
IF new_w%<>-1
window_array%(index&,0)=new_w%                        !set new width in window array
ENDIF
IF new_h%<>-1
window_array%(index&,1)=new_h%                        !set new height in window array
ENDIF
IF step_x&<>-1
window_array&(index&,9)=step_x&                         !set scroll step in window array
ENDIF
IF step_y&<>-1
window_array&(index&,10)=step_y&                         !set scroll step in window array
ENDIF
@win_resize(index&,-1,-1,-1,-1)
IF zero!
@win_set_offset(index&,0,0)
ENDIF
RETURN
> FUNCTION win_kind_create(mode&,tool&,tree&,info!,icfy!,limitsiz!,alw_redr!,offs_scr!,siz_scr!,blit!,backgr!,align&,vdiw!)       !call
$F%
LOCAL kind%
CLR kind%
SELECT mode&
CASE 1 ! prg-modal
LET kind%=BSET(kind%,13)
CASE 2 ! toolbox
LET kind%=BSET(kind%,14)
ENDSELECT
SELECT tool&
CASE 1 ! toolstrip
LET kind%=BSET(kind%,1)
CASE 2 ! toolbar
LET kind%=BSET(kind%,2)
CASE 3 ! windowmenu
LET kind%=BSET(kind%,5)
ENDSELECT
IF tree&=>0
LET kind%=BSET(kind%,0)
ENDIF
IF limitsiz!
LET kind%=BSET(kind%,3)
ENDIF
IF alw_redr!
LET kind%=BSET(kind%,4)
ENDIF
IF offs_scr!
LET kind%=BSET(kind%,6)
ENDIF
IF siz_scr!
LET kind%=BSET(kind%,7)
ENDIF
IF blit!
LET kind%=BSET(kind%,8)
ENDIF
IF backgr!
LET kind%=BSET(kind%,9)
ENDIF
SELECT align&
CASE 1 ! byte
LET kind%=BSET(kind%,10)
CASE 2 ! word
LET kind%=BSET(kind%,11)
ENDSELECT
IF vdiw!
LET kind%=BSET(kind%,12)
ENDIF
LET kind%=BSET(kind%,16)      ! name
LET kind%=BSET(kind%,17)      ! close
LET kind%=BSET(kind%,18)      ! full
LET kind%=BSET(kind%,19)      ! move
IF info!
LET kind%=BSET(kind%,20)      ! info
ENDIF
LET kind%=BSET(kind%,21)      ! size
LET kind%=BSET(kind%,22)      ! uparrow
LET kind%=BSET(kind%,23)      ! dnarrow
LET kind%=BSET(kind%,24)      ! vslide
LET kind%=BSET(kind%,25)      ! lfarrow
LET kind%=BSET(kind%,26)      ! rtarrow
LET kind%=BSET(kind%,27)      ! hslide
IF icfy!
LET kind%=BSET(kind%,30)      ! icfy
ENDIF
RETURN kind%
ENDFUNC
> PROCEDURE rsc_ob_disable(tree&,object&,flag!)                           !call
LOCAL tree%
tree%=@xrsrc_gaddr(0,tree&)
IF flag!
OB_STATE(tree%,object&)=BSET(OB_STATE(tree%,object&),3)
ELSE
OB_STATE(tree%,object&)=BCLR(OB_STATE(tree%,object&),3)
ENDIF
RETURN
> PROCEDURE evnt_multi_loop                                               !call
LOCAL event&,mx&,my&,mb&,ks&,key&,mc&,time&
DO
CLR time&
LET evnt_flags&=&X110011
event&=EVNT_MULTI(evnt_flags&,1,1,1,0,0,0,0,0,0,0,0,0,0,0,time&,mx&,my&,mb&,ks&,key&,mc&)
IF BTST(event&,0)
@handle_keypress(ks&,key&)
ENDIF
IF BTST(event&,1)
@main_loop_mouse(mx&,my&,mb&,ks&,key&,mc&)
ENDIF
IF BTST(event&,4)
@main_message(mx&,my&,mc&,ks&,MENU(1),MENU(2),MENU(3),MENU(4),MENU(5),MENU(6),MENU(7),MENU(8))
ENDIF
LOOP UNTIL BTST(event&,5)
RETURN
FUNCTION fileselector$(title$,path$,file$,path_only!,abbruch$)                   !call
LOCAL error&,button&,aes&
LOCAL wx&,wy&,ww&,wh&,fx&,fy&,fw&,fh&,h&
LET aes&=INT{{GB+4}}
IF (aes&>=&H140 AND aes&<&H200) OR aes&>=&H300 OR @fsel_cookie<>0
title$=LEFT$(title$,30)+CHR$(0)         ! Titel
path$=path$+CHR$(0)+SPACE$(400)
file$=file$+CHR$(0)+SPACE$(150)
GCONTRL(0)=91
GCONTRL(1)=0
GCONTRL(2)=2
GCONTRL(3)=3
GCONTRL(4)=0
ADDRIN(0)=V:path$     ! Pfad
ADDRIN(1)=V:file$     ! Datei
ADDRIN(2)=V:title$        ! Titel
GEMSYS
path$=CHAR{V:path$}   ! Pfad
file$=CHAR{V:file$}   ! Dateiname
LET button&=GINTOUT(1)         ! Abbruch=0, OK=1
LET error&=GINTOUT(0)     ! Fehlercode
ELSE
~WIND_GET(0,4,wx&,wy&,ww&,wh&)
LET fw&=324
IF wh&<350
LET fh&=156
ELSE
LET fh&=308
ENDIF
LET fx&=PRED(SUB(ww&,fw&)\2)
LET fy&=PRED(SUB(wh&,fh&)\2)
LET title$=" "+LEFT$(title$,30)+" "+CHR$(0)
LET h&=WIND_CREATE(1,fx&,fy&,fw&,wy&)
IF h&<>0
~WIND_SET(h&,2,WORD(SHR(V:title$,16)),WORD(V:title$),0,0)
~WIND_OPEN(h&,fx&,fy&,fw&,wy&)
ENDIF
error&=FSEL_INPUT(path$,file$,button&)
IF h&<>0
~WIND_CLOSE(h&)
~WIND_DELETE(h&)
ENDIF
ENDIF
IF button&=1 AND error&<>0
IF path_only!
RETURN LEFT$(path$,RINSTR(path$,"\"))
ELSE
IF file$<>""
RETURN LEFT$(path$,RINSTR(path$,"\"))+file$
ELSE
RETURN ""
ENDIF
ENDIF
ELSE
RETURN abbruch$
ENDIF
ENDFUNC
> FUNCTION file_drive$(file$)                                             !call
RETURN LEFT$(file$,INSTR(file$,":"))
ENDFUNC
> FUNCTION file_path$(file$)                                              !call
LOCAL doppelpunkt&,backslash&
LET backslash&=RINSTR(file$,"\")
IF backslash&
RETURN LEFT$(file$,backslash&)
ELSE
LET doppelpunkt&=INSTR(file$,":")
RETURN LEFT$(file$,doppelpunkt&)
ENDIF
ENDFUNC
> FUNCTION file_name$(file$)                                              !call
LOCAL backslash&,punkt&,doppelpunkt&
LET backslash&=RINSTR(file$,"\")
IF backslash&
LET file$=MID$(file$,SUCC(backslash&))
ELSE
LET doppelpunkt&=INSTR(file$,":")
LET file$=MID$(file$,SUCC(doppelpunkt&))
ENDIF
LET punkt&=RINSTR(file$,".")
IF punkt&
RETURN LEFT$(file$,PRED(punkt&))
ELSE
RETURN file$
ENDIF
ENDFUNC
> FUNCTION file_ext$(file$)                                               !call
LOCAL backslash&,punkt&
LET backslash&=RINSTR(file$,"\")
LET punkt&=RINSTR(file$,".")
IF punkt&>backslash&
RETURN MID$(file$,SUCC(punkt&))
ELSE
RETURN ""
ENDIF
ENDFUNC
> FUNCTION act_drv$                                                       !call
RETURN CHR$(ADD(GEMDOS(25),65))
ENDFUNC
> FUNCTION act_path$                                                      !call
RETURN CHR$(ADD(GEMDOS(25),65))+":"+DIR$(GEMDOS(25)+1)+"\"
ENDFUNC
> PROCEDURE rsc_ob_hide(tree&,object&,flag!)                              !call
LOCAL tree%
tree%=@xrsrc_gaddr(0,tree&)
IF flag!
OB_FLAGS(tree%,object&)=BSET(OB_FLAGS(tree%,object&),7)
ELSE
OB_FLAGS(tree%,object&)=BCLR(OB_FLAGS(tree%,object&),7)
ENDIF
RETURN
> PROCEDURE win_keyb_scroll(index&,handle&,ks&,key&)                      !call
LOCAL m4&,scroll!,old_keyb&
LET old_keyb&=WORD(GEMDOS(340,&HC,L:&H484,L:0))
IF old_keyb&<0
LET old_keyb&=PEEK(&H484)
ENDIF
IF GEMDOS(340,&HF,L:&H484,L:BCLR(old_keyb&,1))<>-36
SPOKE &H484,BCLR(old_keyb&,1)
ENDIF
CLR scroll!
SELECT BYTE(SHR(key&,8))
CASE 71               !clr/home
IF ks& AND &X11
@aes_internal_message(25,handle&,1000,0,0,0)
@aes_internal_message(26,handle&,1000,0,0,0)
ELSE
@aes_internal_message(25,handle&,0,0,0,0)
@aes_internal_message(26,handle&,0,0,0,0)
ENDIF
CASE 72               !up arrow
scroll!=TRUE
IF ks& AND &X11
m4&=0
ELSE
m4&=2
ENDIF
CASE 75               !left arrow
scroll!=TRUE
IF ks& AND &X11
m4&=4
ELSE
m4&=6
ENDIF
CASE 77               !right arrow
scroll!=TRUE
IF ks& AND &X11
m4&=5
ELSE
m4&=7
ENDIF
CASE 80               !down arrow
scroll!=TRUE
IF ks& AND &X11
m4&=1
ELSE
m4&=3
ENDIF
CASE 73               ! page up
IF ks& AND &X11
@aes_internal_message(26,handle&,0,0,0,0)
ELSE
scroll!=TRUE
m4&=0
ENDIF
CASE 81               ! page down
IF ks& AND &X11
@aes_internal_message(26,handle&,1000,0,0,0)
ELSE
scroll!=TRUE
m4&=1
ENDIF
ENDSELECT
IF scroll!
@aes_internal_message(24,handle&,m4&,0,0,0)
ENDIF
IF GEMDOS(340,&HF,L:&H484,L:old_keyb&)<>-36
SPOKE &H484,old_keyb&
ENDIF
RETURN
' GEMDOS-Dateifunktionen
> FUNCTION pdomain(wert&)
$F%
' wert=1 ein
' wert=0 aus
' wert=-1 Status
RETURN GEMDOS(281,wert&)
ENDFUNC
> FUNCTION f_open(a$)
$F%
'
' OPEN "I"
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(61,L:V:a$,0)
ENDFUNC
> FUNCTION f_create(a$)
$F%
'
' OPEN "O"
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(60,L:V:a$,0)
ENDFUNC
> FUNCTION f_update(a$)
$F%
'
' OPEN "U"
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(61,L:V:a$,2)
ENDFUNC
> FUNCTION f_input$(fh&,unix!)
$F%
LOCAL a$,neu$
LOCAL pos1&,pos2&,pos&
'
IF unix!=FALSE
b$=CHR$(13)+CHR$(10)    ! Linefeed 1
c$=CHR$(10)+CHR$(13)    ! Linefeed 2
ENDIF
IF unix!=TRUE
b$=CHR$(10)     ! Linefeed 3 Unixzeilenden
ENDIF
'
REPEAT
LET neu$=SPACE$(80)
LET neu$=LEFT$(neu$,GEMDOS(63,fh&,L:80,L:V:neu$))
LET a$=a$+neu$
IF unix!=FALSE
LET pos1&=INSTR(a$,b$)
LET pos2&=INSTR(a$,c$)
ELSE IF unix!=TRUE
LET pos1&=INSTR(a$,b$)
ENDIF
IF pos1&=0
LET pos&=pos2&
ELSE IF pos2&=0
LET pos&=pos1&
ELSE
LET pos&=MIN(pos1&,pos2&)
ENDIF
UNTIL pos&<>0 OR LEN(neu$)=0
IF pos&>0
IF unix!=FALSE
~GEMDOS(66,L:SUCC(SUB(pos&,LEN(a$))),fh&,1)
ELSE IF unix!=TRUE
~GEMDOS(66,L:SUCC(SUB(PRED(pos&),LEN(a$))),fh&,1)
ENDIF
LET a$=LEFT$(a$,PRED(pos&))
ENDIF
RETURN a$
ENDFUNC
> FUNCTION f_println(fh&,a$,unix!)
$F%
'
' PRINT #1,a$
'
IF unix!=FALSE
a$=a$+CHR$(13)+CHR$(10)
ELSE IF unix!=TRUE
a$=a$+CHR$(10)
ENDIF
'
RETURN GEMDOS(64,fh&,L:LEN(a$),L:V:a$)
ENDFUNC
> FUNCTION exist(f$,i|)                    ! i|=16: nur Ordner,
'                                      ! i|= 8: nur Diskname,
' EXIST()                              ! i|=39: alle anderen Namen
'                                      ! i|=63: alle Namen
f$=f$+CHR$(0)                          ! Nullbyte anhÑngen
~FSETDTA(BASEPAGE+128)
RETURN GEMDOS(78,L:V:f$,i|)
ENDFUNC
> FUNCTION f_bload(file$,adr%)
$F%
LOCAL fh&,lof%,pos%
'
' BLOAD file$,adr%
'
file$=file$+CHR$(0)
'
~GRAF_MOUSE(2,0)
'
fh&=GEMDOS(61,L:V:file$,0)      ! f_open
IF fh&>0
'
pos%=GEMDOS(66,L:0,fh&,1)     ! LOC(#1)
lof%=GEMDOS(66,L:0,fh&,2)     ! f_seek(LOF(#1))
~GEMDOS(66,L:pos%,fh&,0)      ! f_seek(LOC(#1))
'
~GEMDOS(63,fh&,L:lof%,L:adr%) ! f_read
~GEMDOS(62,fh&)               ! f_close
'
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN lof%                     ! LÑnge der Datei
ENDFUNC
> FUNCTION f_bsave(file$,adr%,lof%)
$F%
LOCAL fh&
'
' BSAVE file$,adr%,lof%
'
file$=file$+CHR$(0)
'
~GRAF_MOUSE(2,0)
'
fh&=GEMDOS(60,L:V:file$,0)      ! f_create
IF fh&>0
'
~GEMDOS(64,fh&,L:lof%,L:adr%) ! f_write
~GEMDOS(62,fh&)               ! f_close
'
ENDIF
'
~GRAF_MOUSE(0,0)
'
RETURN fh&
ENDFUNC
> FUNCTION f_lof(fh&)
$F%
LOCAL pos%,lof%
'
' LOF(#1)
'
pos%=GEMDOS(66,L:0,fh&,1)                       ! LOC(#1)
lof%=GEMDOS(66,L:0,fh&,2)                       ! SEEK #1,LOF(#1)
'
~GEMDOS(66,L:pos%,fh&,0)                        ! SEEK #1,LOC(#1)
'
RETURN lof%
ENDFUNC
> FUNCTION f_eof(fh&)
$F%
LOCAL pos%,lof%
'
' EOF(#1)
'
pos%=GEMDOS(66,L:0,fh&,1)                       ! LOC(#1)
lof%=GEMDOS(66,L:0,fh&,2)                       ! SEEK #1,LOF(#1)
'
~GEMDOS(66,L:pos%,fh&,0)                        ! SEEK #1,LOC(#1)
'
RETURN pos%>=lof%                               ! EOF(#1)
ENDFUNC
> FUNCTION f_close(fh&)
$F%
RETURN GEMDOS(62,fh&)
ENDFUNC
'
> FUNCTION fchmod(a$,mode)
$F%
a$=a$+CHR$(0)
RETURN GEMDOS(306,L:V:a$,mode)
ENDFUNC
' GEMDOS-Verzeichnisfunktionen
> FUNCTION akt_drv$
'
' Erstellt am ??.??.???? von Holger Herzog
'
' Version 1.0
'
' Gibt den Buchstaben des aktuellen Laufwerks zurÅck.
'
'    @akt_pfad$()     <== akt. Pfad
'
' Version 1.0         ??.??.???? Holger Herzog
'
RETURN CHR$(ADD(GEMDOS(25),65))
ENDFUNC
> FUNCTION akt_pfad$
'
' Erstellt am ??.??.???? von Holger Herzog
'
' Version 1.01
'
' Gibt den aktuellen Zugriffspfad zurÅck.
'
'    @akt_pfad$()     <== akt. Pfad
'
' Version 1.0         ??.??.???? Holger Herzog
' Version 1.01        06.09.1996 Holger Herzog
'                     Aktuelles Laufwerk nicht mehr Åber @akt_drv
'
RETURN CHR$(ADD(GEMDOS(25),65))+":"+DIR$(0)+"\"
ENDFUNC
> FUNCTION exist_ordner(ordner$)
$F%
' gibt TRUE zurÅck, falls ein bestimmter Ordner exisiert
' Aufrufbeispiel: IF @exist_ordner("C:\WORDPLUS")=TRUE
~FSETDTA(BASEPAGE+128)             ! Setzen der Disktransferadresse
' Dateisuche mit gesetztem Ordnerbit,
IF FSFIRST(ordner$+CHR$(0),&X10000)=0
RETURN TRUE                      ! findet aber auch normale Dateien
ELSE
RETURN FALSE
ENDIF
ENDFUNC
> FUNCTION dsetdrv(drv$)
'
drv%=ASC(drv$)-65
error%=GEMDOS(14,drv%)
RETURN error%
ENDFUNC
> FUNCTION dsetpath(path$)
'
path$=path$+CHR$(0)
error%=GEMDOS(59,L:V:path$)
RETURN error%
ENDFUNC
> FUNCTION f_kill(a$)
$F%
'
' KILL a$
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(65,L:V:a$)
ENDFUNC
> FUNCTION f_rmdir(a$)
$F%
'
' RMDIR a$
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(58,L:V:a$)
ENDFUNC
> FUNCTION f_mkdir(a$)
$F%
'
' MKDIR a$
'
a$=a$+CHR$(0)
'
RETURN GEMDOS(57,L:V:a$)
ENDFUNC
> PROCEDURE rsc_ob_flags(tree&,object&,number&,flag!)                     !call
LOCAL tree%
tree%=@xrsrc_gaddr(0,tree&)
IF flag!
OB_FLAGS(tree%,object&)=BSET(OB_FLAGS(tree%,object&),number&)
ELSE
OB_FLAGS(tree%,object&)=BCLR(OB_FLAGS(tree%,object&),number&)
ENDIF
RETURN
> PROCEDURE rsc_ob_state(tree&,object&,number&,flag!)                     !call
LOCAL tree%
tree%=@xrsrc_gaddr(0,tree&)
IF flag!
OB_STATE(tree%,object&)=BSET(OB_STATE(tree%,object&),number&)
ELSE
OB_STATE(tree%,object&)=BCLR(OB_STATE(tree%,object&),number&)
ENDIF
RETURN
> PROCEDURE set_cursor(index&,object&)                                    !call
IF BTST(OB_FLAGS(window_tree%(index&,0),object&),3) AND NOT BTST(OB_STATE(window_tree%(index&,0),object&),3)
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
window_array&(index&,2)=object&
window_array&(index&,3)=LEN(CHAR{{OB_SPEC(window_tree%(index&,0),object&)}})
@cursor_on(index&)
ENDIF
RETURN
> PROCEDURE rsc_ob_reset(tree&,ob&)                                       !call
LOCAL index&
LOCAL top_handle&,d&
~WIND_GET(0,10,top_handle&,d&,d&,d&)
@rsc_setup_tree(tree&)
FOR index&=0 TO max_number_windows&
IF window_array&(index&,0)>0
IF tree&=window_array&(index&,4)
@aes_screen_lock_only_screen
IF top_handle&=window_array&(index&,0) AND window_array&(index&,2)<>0
~OBJC_EDIT(window_tree%(index&,0),window_array&(index&,2),0,window_array&(index&,3),3,window_array&(index&,3))
ENDIF
@rsc_ob_draw(index&,ob&)
IF top_handle&=window_array&(index&,0) AND window_array&(index&,2)<>0
@cursor_on(index&)
ENDIF
@aes_screen_unlock_only_screen
ENDIF
ENDIF
NEXT index&
RETURN
> PROCEDURE messagewin_open(title$,maxlines%,x&,y&,w&,h&,icfyicon&)         !call
  '
  ' Version 1.1  03.03.1998  Holger Herzog
  '
  LET messagewin_userhandle_&=-2551   ! +SYM
  '
  IF messagewin_windowhandle_&<>0
    @messagewin_close
  ENDIF
  '
  LET messagewin_maxline_%=PRED(maxlines%)
  DIM messagewin_$(messagewin_maxline_%),messagewin_selected_!(messagewin_maxline_%)
  LET messagewin_entries_%=0
  '
  LET messagewin_windowhandle_&=@textlist_win_open(title$,"",0,0,-1,messagewin_userhandle_&,x&,y&,w&,h&,icfyicon&,messagewin_entries_%,messagewin_$())
  IF messagewin_windowhandle_&=0
    ERASE messagewin_$(),messagewin_selected_!()
  ENDIF
  '
RETURN
> PROCEDURE messagewin_print(line$)                                         !call
  '
  ' Version 1.0  03.03.1998  Holger Herzog
  '
  LOCAL index&
  '
  IF messagewin_windowhandle_&<>0
    '
    LET index&=@win_get_index(messagewin_windowhandle_&)
    '
    IF messagewin_entries_%>messagewin_maxline_%
      DELETE messagewin_$(0)
      @win_move_content(index&,0,window_array&(index&,10),0,0,window_array%(index&,0),SUB(window_array%(index&,1),window_array&(index&,10)))
    ELSE
      INC messagewin_entries_%
    ENDIF
    '
    LET messagewin_$(PRED(messagewin_entries_%))=line$
    @textlist_redraw(index&,PRED(messagewin_entries_%))
    '
    @textlist_resize(index&,messagewin_entries_%,messagewin_$())
    @win_set_offset(index&,-1,-2)
    '
  ENDIF
  '
RETURN
> PROCEDURE messagewin_close                                                !call
  '
  ' Version 1.0  03.03.1998  Holger Herzog
  '
  @win_close(messagewin_windowhandle_&)
  CLR messagewin_windowhandle_&
  ERASE messagewin_$(),messagewin_selected_!()
  '
RETURN
> FUNCTION textlist_win_open(title$,info$,mode&,tool&,tree&,userhandle&,x&,y&,w&,h&,iconify&,num%,VAR list$())       ! call
$F%
'
' Version 1.0  30.03.1997  Holger Herzog
' Version 1.2  17.03.1998  Holger Herzog
'              32-Bit windowengine
'
LOCAL totw%,toth%
LOCAL scrlstep&
LOCAL kind%
LOCAL handle&
LOCAL info!
'
' *** Fenstergrîûe errechnen ***
'
LET info!=(info$<>"")
LET kind%=@win_kind_create(mode&,tool&,tree&,info!,TRUE,FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,1,TRUE)
'
IF x&=(-1) AND y&=(-1) AND w&=(-1) AND h&=(-1)
~WIND_GET(0,4,x&,y&,w&,h&)                       ! Desktopgrîûe ermitteln
ENDIF
'
LET scrlstep&=@textlist_scrlstep_get
LET totw%=@textlist_totw_get(num%,scrlstep&,list$())
LET toth%=@textlist_toth_get(num%)
'
' *** Fenster îffnen ***
'
LET handle&=@win_open(title$,info$,kind%,tree&,totw%,toth%,@textlist_font_width,scrlstep&,userhandle&,x&,y&,w&,h&,iconify&)
'
RETURN handle&
'
ENDFUNC
> PROCEDURE textlist_draw(index&,off_x%,off_y%,cx&,cy&,cw&,ch&,num%,VAR list$(),selected!())
'
' Version 1.1  27.01.1997  Holger Herzog
' Version 1.2  29.03.1997  Holger Herzog
'              some fixes
' Version 1.3  17.03.1998 Holger Herzog
'              32-Bit windowengine
'
LOCAL line%,font_h&
LOCAL xlauf%,xend%,ylauf%,yend%
LOCAL startline%,endline%
LOCAL len&,col&,cols&
LOCAL wx&,wy&,ww&,wh&
LOCAL x%,y%,w&,h&
LOCAL text$
'
@win_get_workarea(index&,wx&,wy&,ww&,wh&)
'
IF RC_INTERSECT(wx&,wy&,ww&,wh&,cx&,cy&,cw&,ch&)
'
' *** Textausrichtung ***
'
INTIN(0)=0
INTIN(1)=5
CONTRL(0)=39
CONTRL(1)=0
CONTRL(3)=2
CONTRL(6)=V~H
VDISYS
'
LET font_h&=@textlist_font_height
LET x%=ADD(SUB(cx&,wx&),off_x%)
LET y%=ADD(SUB(cy&,wy&),off_y%)
LET w&=cw&
LET h&=ch&
LET startline%=y% DIV font_h&
LET endline%=MIN(PRED(num%),PRED(ADD(y%,h&)) DIV font_h&)
LET xend%=ADD(wx&,ADD(off_x%,ww&))
LET yend%=ADD(wy&,ADD(off_y%,wh&))
'
GRAPHMODE 1
BOUNDARY 0
DEFFILL 0,1
'
IF FRE()<4096
~FRE(0)
ENDIF
'
LET ylauf%=SUB(MUL(startline%,font_h&),off_y%)
FOR line%=startline% TO endline%
LET xlauf%=SUB(0,off_x%)
LET len&=LEN(list$(line%))
LET col&=1
WHILE col&<=len&
LET cols&=MIN(80,SUCC(SUB(len&,col&)))
LET text$=MID$(list$(line%),col&,cols&)
TEXT xlauf%,ylauf%,text$
~VQT_EXTENT(text$)
ADD xlauf%,PTSOUT(2)
ADD col&,cols&
WEND
IF xlauf%<xend%
PBOX xlauf%,ylauf%,xend%,PRED(ADD(ylauf%,font_h&))
ENDIF
IF selected!(line%)
GRAPHMODE 3
DEFFILL 1,1
PBOX 0,ylauf%,xend%,PRED(ADD(ylauf%,font_h&))
GRAPHMODE 1
DEFFILL 0,1
ENDIF
ADD ylauf%,font_h&
NEXT line%
'
IF ylauf%<yend%
DEFFILL 0,1
PBOX 0,ylauf%,xend%,yend%
ENDIF
'
ENDIF
'
RETURN
> FUNCTION textlist_click(index&,mx&,my&,mb&,ks&,mc&,dd!,num%,VAR selected!(),hash&())    !call
$F%
'
' Version 1.0  25.09.1996  Holger Herzog
' Version 1.1  29.03.1997  Holger Herzog
'              new: dd!-flag, some changes
' Version 1.2         17.03.1998 Holger Herzog
'                     32-Bit windowengine
'
LOCAL wx&,wy&,ww&,wh&
LOCAL mw&,mh&,dummy&
LOCAL line%,font_h&
LOCAL ret&,select!,shift!
LOCAL i%
LOCAL dx&,dy&,dw&,dh&
LOCAL sx&,sy&
LOCAL dest&
'
LET ret&=-1                   ! returnvalue
LET font_h&=@textlist_font_height
'
@aes_screen_lock
'
IF BTST(mb&,0)
'
' *** leftclick ***
'
LET shift!=(AND(ks&,&X11)<>0)     ! shift
'
' *** get window-workarea ***
'
LET mw&=1
LET mh&=1
@win_get_workarea(index&,wx&,wy&,ww&,wh&)
'
' +++ mouse in window? +++
'
IF RC_INTERSECT(wx&,wy&,ww&,wh&,mx&,my&,mw&,mh&)
'
LET line%=ADD(window_array%(index&,3),SUB(my&,wy&)) DIV font_h&
'
IF line%=>0 AND line%<num%
'
' +++ mouse-pos on a selectable line? +++
'
IF hash&(line%)=>0
'
LET select!=NOT selected!(line%)
'
' +++ drag&drop? +++
'
~EVNT_MULTI(&X100010,1,1,0,0,0,0,0,0,0,0,0,0,0,0,150)
~GRAF_MKSTATE(mx&,my&,mb&,ks&)
LET dd!=dd! AND BTST(mb&,0)
'
IF NOT (shift! OR (dd! AND (NOT select!)))
'
' +++ deselect all +++
'
FOR i%=0 TO PRED(num%)
IF selected!(i%) AND i%<>line%
LET selected!(i%)=FALSE
@textlist_redraw(index&,i%)
ENDIF
NEXT i%
ENDIF
'
LET select!=select! OR dd!
'
IF mc&>1                        ! doubleclick
LET ret&=hash&(line%)
LET select!=TRUE
ELSE
LET ret&=-1
ENDIF
'
' +++ (de)select current line if necc. +++
'
IF selected!(line%)<>select!
LET selected!(line%)=select!
@textlist_redraw(index&,line%)
ENDIF
'
' *** drag&drop? **
'
IF dd!
'
' +++ long click => drag&drop +++
'
~WIND_GET(0,4,dx&,dy&,dw&,dh&)
~GRAF_DRAGBOX(MUL(font_h&,6),font_h&,SUB(mx&,MUL(font_h&,3)),SUB(my&,SUB(my&,wy&) MOD font_h&),dx&,dy&,dw&,dh&,sx&,sy&)
'
LET dest&=@win_get_index(WIND_FIND(sx&,sy&))
IF dest&=>0
@win_get_workarea(dest&,wx&,wy&,ww&,wh&)
SUB sx&,wx&
SUB sy&,wy&
@user_textlist_dragdrop(index&,dest&,sx&,sy&)
ELSE
OUT 2,7
ENDIF
'
ENDIF
'
ELSE            ! sizebox
'
' not implemented, yet
'
OUT 2,7
'
ENDIF
ENDIF
'
ENDIF
'
ENDIF
'
REPEAT
~GRAF_MKSTATE(mx&,my&,mb&,dummy&)
UNTIL mb&=0
'
'
WHILE BTST(EVNT_MULTI(&X100010,1,1,1,0,0,0,0,0,0,0,0,0,0,0,3),1)
WEND
WHILE BTST(EVNT_MULTI(&X100001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50),0)
WEND
@aes_screen_unlock
'
RETURN ret&
'
ENDFUNC
> PROCEDURE textlist_redraw(index&,line%)                                 !call
'
' Version 1.0         23.09.1996 Holger Herzog
' Version 1.1         29.03.1997 Holger Herzog
'                     Fix: font_h had to be 16
' Version 1.2         17.03.1998 Holger Herzog
'                     32-Bit windowengine
'
LOCAL wx&,wy&,ww&,wh&
LOCAL lx&,ly&,lw&,lh&,ly%
LOCAL font_h&
'
@win_get_workarea(index&,wx&,wy&,ww&,wh&)
LET font_h&=@textlist_font_height
'
LET lx&=wx&
LET ly%=ADD(wy&,SUB(MUL(line%,font_h&),window_array%(index&,3)))
LET ly&=WORD(ly%)
LET lw&=ww&
LET lh&=font_h&
'
IF ly%=ly&
IF RC_INTERSECT(wx&,wy&,ww&,wh&,lx&,ly&,lw&,lh&)
@redraw_userwindow(window_array&(index&,0),lx&,ly&,lw&,lh&)
ENDIF
ENDIF
'
RETURN
> PROCEDURE textlist_resize(index&,num%,VAR list$())              !call
'
' Version 1.0  31.03.1997  Holger Herzog
' Version 1.2         17.03.1998 Holger Herzog
'                     32-Bit windowengine
'
LOCAL totw%,toth%
LOCAL scrlstep&
'
LET scrlstep&=@textlist_scrlstep_get
LET totw%=@textlist_totw_get(num%,scrlstep&,list$())
LET toth%=@textlist_toth_get(num%)
'
@win_change_size(index&,totw%,toth%,@textlist_font_width,scrlstep&,FALSE)
'
RETURN
> FUNCTION textlist_totw_get(num%,scrlstep&,VAR list$())
$F%
'
' Version 1.0  30.03.1997  Holger Herzog
' Version 1.2         17.03.1998 Holger Herzog
'                     32-Bit windowengine
'
LOCAL totw%,line%
'
CLR totw%
'
FOR line%=0 TO PRED(num%)
LET totw%=MAX(totw%,@textlist_text_width(list$(line%)))
NEXT line%
'
LET totw%=MUL(SUCC(PRED(totw%) DIV scrlstep&),scrlstep&)
'
RETURN totw%
'
ENDFUNC
> FUNCTION textlist_toth_get(num%)
$F%
'
' Version 1.0  30.03.1997  Holger Herzog
' Version 1.2         17.03.1998 Holger Herzog
'                     32-Bit windowengine
'
RETURN MUL(num%,@textlist_font_height)
'
ENDFUNC
> FUNCTION textlist_scrlstep_get
$F%
'
' Version 1.0  30.03.1997  Holger Herzog
'
RETURN @textlist_font_height
'
ENDFUNC
> FUNCTION textlist_font_width
$F%
'
' Version 1.0  27.01.1997  Holger Herzog
' Version 1.1  31.03.1997  Holger Herzog
'
CONTRL(0)=131
CONTRL(1)=0
CONTRL(3)=0
VDISYS
RETURN PTSOUT(0)
ENDFUNC
> FUNCTION textlist_font_height
$F%
'
' Version 1.0  27.01.1997  Holger Herzog
' Version 1.1  31.03.1997  Holger Herzog
'
CONTRL(0)=131
CONTRL(1)=0
CONTRL(3)=0
VDISYS
RETURN SUCC(ADD(PTSOUT(1),PTSOUT(9)))
ENDFUNC
> FUNCTION textlist_text_width(text$)
$F%
'
' Version 1.0  27.01.1997  Holger Herzog
' Version 1.1  31.03.1997  Holger Herzog
' Version 1.2         17.03.1998 Holger Herzog
'                     32-Bit windowengine
'
LOCAL w%,len&,pos&,act&
CLR w%
LET pos&=1
LET len&=LEN(text$)
'
WHILE len&>0
LET act&=MIN(110,len&)
~VQT_EXTENT(MID$(text$,pos&,act&))
ADD w%,PTSOUT(2)
SUB len&,act&
ADD pos&,act&
WEND
'
RETURN w%
ENDFUNC
